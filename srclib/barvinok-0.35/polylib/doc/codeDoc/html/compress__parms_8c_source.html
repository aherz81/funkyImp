<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>polylib: compress_parms.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">polylib&#160;<span id="projectnumber">5.22.5</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('compress__parms_8c.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">compress_parms.c</div>  </div>
</div>
<div class="contents">
<a href="compress__parms_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">    This file is part of PolyLib.</span>
<a name="l00003"></a>00003 <span class="comment"></span>
<a name="l00004"></a>00004 <span class="comment">    PolyLib is free software: you can redistribute it and/or modify</span>
<a name="l00005"></a>00005 <span class="comment">    it under the terms of the GNU General Public License as published by</span>
<a name="l00006"></a>00006 <span class="comment">    the Free Software Foundation, either version 3 of the License, or</span>
<a name="l00007"></a>00007 <span class="comment">    (at your option) any later version.</span>
<a name="l00008"></a>00008 <span class="comment"></span>
<a name="l00009"></a>00009 <span class="comment">    PolyLib is distributed in the hope that it will be useful,</span>
<a name="l00010"></a>00010 <span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00011"></a>00011 <span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00012"></a>00012 <span class="comment">    GNU General Public License for more details.</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">    You should have received a copy of the GNU General Public License</span>
<a name="l00015"></a>00015 <span class="comment">    along with PolyLib.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<a name="l00016"></a>00016 <span class="comment">*/</span>
<a name="l00017"></a>00017 <span class="comment"></span>
<a name="l00018"></a>00018 <span class="comment">/** </span>
<a name="l00019"></a>00019 <span class="comment"> * $Id: compress_parms.c,v 1.32 2006/11/03 17:34:26 skimo Exp $</span>
<a name="l00020"></a>00020 <span class="comment"> *</span>
<a name="l00021"></a>00021 <span class="comment"> * The integer points in a parametric linear subspace of Q^n are generally</span>
<a name="l00022"></a>00022 <span class="comment"> * lying on a sub-lattice of Z^n.  </span>
<a name="l00023"></a>00023 <span class="comment"> * Functions here use and compute validity lattices, i.e. lattices induced on a</span>
<a name="l00024"></a>00024 <span class="comment"> * set of variables by such equalities involving another set of integer</span>
<a name="l00025"></a>00025 <span class="comment"> * variables.</span>
<a name="l00026"></a>00026 <span class="comment"> * @author B. Meister 12/2003-2006 meister@icps.u-strasbg.fr</span>
<a name="l00027"></a>00027 <span class="comment"> * LSIIT -ICPS </span>
<a name="l00028"></a>00028 <span class="comment"> * UMR 7005 CNRS</span>
<a name="l00029"></a>00029 <span class="comment"> * Louis Pasteur University (ULP), Strasbourg, France </span>
<a name="l00030"></a>00030 <span class="comment">*/</span>
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;polylib/polylib.h&gt;</span>
<a name="l00034"></a>00034 <span class="comment"></span>
<a name="l00035"></a>00035 <span class="comment">/** </span>
<a name="l00036"></a>00036 <span class="comment"> * debug flags (2 levels)</span>
<a name="l00037"></a>00037 <span class="comment"> */</span>
<a name="l00038"></a><a class="code" href="compress__parms_8c.html#a22fb119bf6f583cf5b74c2bddaa53e70">00038</a> <span class="preprocessor">#define dbgCompParm 0</span>
<a name="l00039"></a><a class="code" href="compress__parms_8c.html#a964f66a0f36b5e1d0dea475066c53ca0">00039</a> <span class="preprocessor"></span><span class="preprocessor">#define dbgCompParmMore 0</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span>
<a name="l00041"></a><a class="code" href="compress__parms_8c.html#a4df7b5873f125cf5c2976bbd4dcfe168">00041</a> <span class="preprocessor">#define dbgStart(a) if (dbgCompParmMore) { printf(&quot; -- begin &quot;); \</span>
<a name="l00042"></a>00042 <span class="preprocessor">                                           printf(#a);        \</span>
<a name="l00043"></a>00043 <span class="preprocessor">                                           printf(&quot; --\n&quot;); }   \</span>
<a name="l00044"></a>00044 <span class="preprocessor">                                           while(0)</span>
<a name="l00045"></a><a class="code" href="compress__parms_8c.html#a49fcecacd32fa2357935cb5a4f542e0c">00045</a> <span class="preprocessor"></span><span class="preprocessor">#define dbgEnd(a) if (dbgCompParmMore) { printf(&quot; -- end &quot;); \</span>
<a name="l00046"></a>00046 <span class="preprocessor">                                         printf(#a);      \</span>
<a name="l00047"></a>00047 <span class="preprocessor">                                         printf(&quot; --\n&quot;); } \</span>
<a name="l00048"></a>00048 <span class="preprocessor">                                         while(0)</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span>
<a name="l00050"></a>00050 <span class="comment"></span>
<a name="l00051"></a>00051 <span class="comment">/** </span>
<a name="l00052"></a>00052 <span class="comment"> * Given a full-row-rank nxm matrix M made of m row-vectors), computes the</span>
<a name="l00053"></a>00053 <span class="comment"> * basis K (made of n-m column-vectors) of the integer kernel of the rows of M</span>
<a name="l00054"></a>00054 <span class="comment"> * so we have: M.K = 0</span>
<a name="l00055"></a>00055 <span class="comment">*/</span>
<a name="l00056"></a><a class="code" href="compress__parms_8h.html#ad66769b920ca4596c9fe5b76d38d0b3b">00056</a> <a class="code" href="structmatrix.html">Matrix</a> * <a class="code" href="compress__parms_8c.html#ad66769b920ca4596c9fe5b76d38d0b3b" title="Given a full-row-rank nxm matrix M made of m row-vectors), computes the basis K (made of n-m column-v...">int_ker</a>(<a class="code" href="structmatrix.html">Matrix</a> * M) {
<a name="l00057"></a>00057   <a class="code" href="structmatrix.html">Matrix</a> *U, *Q, *H, *H2, *K=NULL;
<a name="l00058"></a>00058   <span class="keywordtype">int</span> i, j, rk;
<a name="l00059"></a>00059 
<a name="l00060"></a>00060   <span class="keywordflow">if</span> (<a class="code" href="compress__parms_8c.html#a22fb119bf6f583cf5b74c2bddaa53e70" title="debug flags (2 levels)">dbgCompParm</a>)
<a name="l00061"></a>00061     <a class="code" href="matrix__addon_8h.html#a11468159c7fa7d75fadfa10e2e929fee" title="Polylib matrix addons Mainly, deals with polyhedra represented in implicit form (set of constraints)...">show_matrix</a>(M);
<a name="l00062"></a>00062   <span class="comment">/* eliminate redundant rows : UM = H*/</span>
<a name="l00063"></a>00063   <a class="code" href="matrix_8c.html#a9d112ac078583626580f848b51a515f3">right_hermite</a>(M, &amp;H, &amp;Q, &amp;U);
<a name="l00064"></a>00064   <span class="keywordflow">for</span> (rk=H-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>-1; (rk&gt;=0) &amp;&amp; <a class="code" href="vector_8c.html#a4f5f43ecdfb5c63f8c3ecbf875887869">Vector_IsZero</a>(H-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[rk], H-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>); rk--);
<a name="l00065"></a>00065   rk++;
<a name="l00066"></a>00066   <span class="keywordflow">if</span> (<a class="code" href="compress__parms_8c.html#a964f66a0f36b5e1d0dea475066c53ca0">dbgCompParmMore</a>) {
<a name="l00067"></a>00067     printf(<span class="stringliteral">&quot;rank = %d\n&quot;</span>, rk);
<a name="l00068"></a>00068   }
<a name="l00069"></a>00069     
<a name="l00070"></a>00070   <span class="comment">/* there is a non-null kernel if and only if the dimension m of </span>
<a name="l00071"></a>00071 <span class="comment">     the space spanned by the rows </span>
<a name="l00072"></a>00072 <span class="comment">     is inferior to the number n of variables */</span>
<a name="l00073"></a>00073   <span class="keywordflow">if</span> (M-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a> &lt;= rk) {
<a name="l00074"></a>00074     <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(H);
<a name="l00075"></a>00075     <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(Q);
<a name="l00076"></a>00076     <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(U);
<a name="l00077"></a>00077     K = <a class="code" href="matrix_8c.html#ac0b29e1d99a2823ad00b5f2157879d80">Matrix_Alloc</a>(M-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>, 0);
<a name="l00078"></a>00078     <span class="keywordflow">return</span> K;
<a name="l00079"></a>00079   }
<a name="l00080"></a>00080   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(U); 
<a name="l00081"></a>00081   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(Q);
<a name="l00082"></a>00082   <span class="comment">/* fool left_hermite  by giving NbRows =rank of M*/</span>
<a name="l00083"></a>00083   H-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>=rk;
<a name="l00084"></a>00084   <span class="comment">/* computes MU = [H 0] */</span>
<a name="l00085"></a>00085   <a class="code" href="matrix_8c.html#adcbe5ee3f0c28fb35aed49f4e1f40f5b">left_hermite</a>(H, &amp;H2, &amp;Q, &amp;U); 
<a name="l00086"></a>00086    <span class="keywordflow">if</span> (<a class="code" href="compress__parms_8c.html#a964f66a0f36b5e1d0dea475066c53ca0">dbgCompParmMore</a>) {
<a name="l00087"></a>00087     printf(<span class="stringliteral">&quot;-- Int. Kernel -- \n&quot;</span>);
<a name="l00088"></a>00088     <a class="code" href="matrix__addon_8h.html#a11468159c7fa7d75fadfa10e2e929fee" title="Polylib matrix addons Mainly, deals with polyhedra represented in implicit form (set of constraints)...">show_matrix</a>(M);
<a name="l00089"></a>00089     printf(<span class="stringliteral">&quot; = \n&quot;</span>);
<a name="l00090"></a>00090     <a class="code" href="matrix__addon_8h.html#a11468159c7fa7d75fadfa10e2e929fee" title="Polylib matrix addons Mainly, deals with polyhedra represented in implicit form (set of constraints)...">show_matrix</a>(H2);
<a name="l00091"></a>00091     <a class="code" href="matrix__addon_8h.html#a11468159c7fa7d75fadfa10e2e929fee" title="Polylib matrix addons Mainly, deals with polyhedra represented in implicit form (set of constraints)...">show_matrix</a>(U); 
<a name="l00092"></a>00092   }
<a name="l00093"></a>00093   H-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>==M-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>;
<a name="l00094"></a>00094   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(H);
<a name="l00095"></a>00095   <span class="comment">/* the Integer Kernel is made of the last n-rk columns of U */</span>
<a name="l00096"></a>00096   <a class="code" href="matrix__addon_8c.html#a33fec91bb879b7b4dda814ad9d33f41b" title="returns a contiguous submatrix of a matrix.">Matrix_subMatrix</a>(U, 0, rk, U-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>, U-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>, &amp;K);
<a name="l00097"></a>00097 
<a name="l00098"></a>00098   <span class="comment">/* clean up */</span>
<a name="l00099"></a>00099   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(H2);
<a name="l00100"></a>00100   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(U);
<a name="l00101"></a>00101   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(Q);
<a name="l00102"></a>00102   <span class="keywordflow">return</span> K;
<a name="l00103"></a>00103 } <span class="comment">/* int_ker */</span>
<a name="l00104"></a>00104 
<a name="l00105"></a>00105 <span class="comment"></span>
<a name="l00106"></a>00106 <span class="comment">/** </span>
<a name="l00107"></a>00107 <span class="comment"> * Computes the intersection of two linear lattices, whose base vectors are</span>
<a name="l00108"></a>00108 <span class="comment"> * respectively represented in A and B.</span>
<a name="l00109"></a>00109 <span class="comment"> * If I and/or Lb is set to NULL, then the matrix is allocated. </span>
<a name="l00110"></a>00110 <span class="comment"> * Else, the matrix is assumed to be allocated already. </span>
<a name="l00111"></a>00111 <span class="comment"> * I and Lb are rk x rk, where rk is the rank of A (or B).</span>
<a name="l00112"></a>00112 <span class="comment"> * @param A the full-row rank matrix whose column-vectors are the basis for the</span>
<a name="l00113"></a>00113 <span class="comment"> * first linear lattice.</span>
<a name="l00114"></a>00114 <span class="comment"> * @param B the matrix whose column-vectors are the basis for the second linear</span>
<a name="l00115"></a>00115 <span class="comment"> * lattice.</span>
<a name="l00116"></a>00116 <span class="comment"> * @param Lb the matrix such that B.Lb = I, where I is the intersection.</span>
<a name="l00117"></a>00117 <span class="comment"> * @return their intersection.</span>
<a name="l00118"></a>00118 <span class="comment"> */</span>
<a name="l00119"></a><a class="code" href="compress__parms_8c.html#a8b044a0b5721eb247eb671644b80df9d">00119</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="compress__parms_8c.html#a8b044a0b5721eb247eb671644b80df9d" title="Computes the intersection of two linear lattices, whose base vectors are respectively represented in ...">linearInter</a>(<a class="code" href="structmatrix.html">Matrix</a> * A, <a class="code" href="structmatrix.html">Matrix</a> * B, <a class="code" href="structmatrix.html">Matrix</a> ** I, <a class="code" href="structmatrix.html">Matrix</a> **Lb) {
<a name="l00120"></a>00120   <a class="code" href="structmatrix.html">Matrix</a> * AB=NULL;
<a name="l00121"></a>00121   <span class="keywordtype">int</span> rk = A-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>;
<a name="l00122"></a>00122   <span class="keywordtype">int</span> a = A-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>;
<a name="l00123"></a>00123   <span class="keywordtype">int</span> b = B-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>;
<a name="l00124"></a>00124   <span class="keywordtype">int</span> i,j, z=0;
<a name="l00125"></a>00125 
<a name="l00126"></a>00126   <a class="code" href="structmatrix.html">Matrix</a> * H, *U, *Q;
<a name="l00127"></a>00127   <span class="comment">/* ensure that the spanning vectors are in the same space */</span>
<a name="l00128"></a>00128   <a class="code" href="assert_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a>(B-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>==rk);
<a name="l00129"></a>00129   <span class="comment">/* 1- build the matrix </span>
<a name="l00130"></a>00130 <span class="comment">   * (A 0 1)</span>
<a name="l00131"></a>00131 <span class="comment">   * (0 B 1)</span>
<a name="l00132"></a>00132 <span class="comment">   */</span>
<a name="l00133"></a>00133   AB = <a class="code" href="matrix_8c.html#ac0b29e1d99a2823ad00b5f2157879d80">Matrix_Alloc</a>(2*rk, a+b+rk);
<a name="l00134"></a>00134   <a class="code" href="matrix__addon_8c.html#acb90cceb8e7a674a3d5796a1402f0c9e" title="Copies a contiguous submatrix of M1 into M2, at the indicated position.">Matrix_copySubMatrix</a>(A, 0, 0, rk, a, AB, 0, 0);
<a name="l00135"></a>00135   <a class="code" href="matrix__addon_8c.html#acb90cceb8e7a674a3d5796a1402f0c9e" title="Copies a contiguous submatrix of M1 into M2, at the indicated position.">Matrix_copySubMatrix</a>(B, 0, 0, rk, b, AB, rk, a);
<a name="l00136"></a>00136   <span class="keywordflow">for</span> (i=0; i&lt; rk; i++) {
<a name="l00137"></a>00137       <a class="code" href="arithmetique_8h.html#a8cc56567a4a29271559ac0fd5f6c5bfa">value_set_si</a>(AB-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][a+b+i], 1);
<a name="l00138"></a>00138       <a class="code" href="arithmetique_8h.html#a8cc56567a4a29271559ac0fd5f6c5bfa">value_set_si</a>(AB-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i+rk][a+b+i], 1);
<a name="l00139"></a>00139   }
<a name="l00140"></a>00140   <span class="keywordflow">if</span> (<a class="code" href="compress__parms_8c.html#a22fb119bf6f583cf5b74c2bddaa53e70" title="debug flags (2 levels)">dbgCompParm</a>) {
<a name="l00141"></a>00141     <a class="code" href="matrix__addon_8h.html#a11468159c7fa7d75fadfa10e2e929fee" title="Polylib matrix addons Mainly, deals with polyhedra represented in implicit form (set of constraints)...">show_matrix</a>(AB);
<a name="l00142"></a>00142   }
<a name="l00143"></a>00143 
<a name="l00144"></a>00144   <span class="comment">/* 2- Compute its left Hermite normal form. AB.U = [H 0] */</span>
<a name="l00145"></a>00145   <a class="code" href="matrix_8c.html#adcbe5ee3f0c28fb35aed49f4e1f40f5b">left_hermite</a>(AB, &amp;H, &amp;Q, &amp;U);
<a name="l00146"></a>00146   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(AB);
<a name="l00147"></a>00147   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(Q);
<a name="l00148"></a>00148   <span class="comment">/* count the number of non-zero colums in H */</span> 
<a name="l00149"></a>00149   <span class="keywordflow">for</span> (z=H-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>-1; <a class="code" href="arithmetique_8h.html#a827532f2140ae2aa96e46baebae09723">value_zero_p</a>(H-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[H-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>-1][z]); z--);
<a name="l00150"></a>00150   z++;
<a name="l00151"></a>00151   <span class="keywordflow">if</span> (<a class="code" href="compress__parms_8c.html#a22fb119bf6f583cf5b74c2bddaa53e70" title="debug flags (2 levels)">dbgCompParm</a>) {
<a name="l00152"></a>00152     <a class="code" href="matrix__addon_8h.html#a11468159c7fa7d75fadfa10e2e929fee" title="Polylib matrix addons Mainly, deals with polyhedra represented in implicit form (set of constraints)...">show_matrix</a>(H);
<a name="l00153"></a>00153     printf(<span class="stringliteral">&quot;z=%d\n&quot;</span>, z);
<a name="l00154"></a>00154   }
<a name="l00155"></a>00155   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(H);
<a name="l00156"></a>00156   <span class="comment">/* if you split U in 9 submatrices, you have: </span>
<a name="l00157"></a>00157 <span class="comment">   * A.U_13 = -U_33</span>
<a name="l00158"></a>00158 <span class="comment">   * B.U_23 = -U_33,</span>
<a name="l00159"></a>00159 <span class="comment">   * where the nb of cols of U_{*3} equals the nb of zero-cols of H</span>
<a name="l00160"></a>00160 <span class="comment">   * U_33 is a (the smallest) combination of col-vectors of A and B at the same</span>
<a name="l00161"></a>00161 <span class="comment">   * time: their intersection.</span>
<a name="l00162"></a>00162 <span class="comment">  */</span>
<a name="l00163"></a>00163   <a class="code" href="matrix__addon_8c.html#a33fec91bb879b7b4dda814ad9d33f41b" title="returns a contiguous submatrix of a matrix.">Matrix_subMatrix</a>(U, a+b, z, U-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>, U-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>, I);
<a name="l00164"></a>00164   <a class="code" href="matrix__addon_8c.html#a33fec91bb879b7b4dda814ad9d33f41b" title="returns a contiguous submatrix of a matrix.">Matrix_subMatrix</a>(U, a, z, a+b, U-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>, Lb);
<a name="l00165"></a>00165   <span class="keywordflow">if</span> (<a class="code" href="compress__parms_8c.html#a22fb119bf6f583cf5b74c2bddaa53e70" title="debug flags (2 levels)">dbgCompParm</a>) {
<a name="l00166"></a>00166     <a class="code" href="matrix__addon_8h.html#a11468159c7fa7d75fadfa10e2e929fee" title="Polylib matrix addons Mainly, deals with polyhedra represented in implicit form (set of constraints)...">show_matrix</a>(U);
<a name="l00167"></a>00167   }
<a name="l00168"></a>00168   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(U);
<a name="l00169"></a>00169 } <span class="comment">/* linearInter */</span>
<a name="l00170"></a>00170 
<a name="l00171"></a>00171 <span class="comment"></span>
<a name="l00172"></a>00172 <span class="comment">/** </span>
<a name="l00173"></a>00173 <span class="comment"> * Given a system of equalities, looks if it has an integer solution in the</span>
<a name="l00174"></a>00174 <span class="comment"> * combined space, and if yes, returns one solution.</span>
<a name="l00175"></a>00175 <span class="comment"> * &lt;p&gt;pre-condition: the equalities are full-row rank (without the constant</span>
<a name="l00176"></a>00176 <span class="comment"> * part)&lt;/p&gt;</span>
<a name="l00177"></a>00177 <span class="comment"> * @param Eqs the system of equations (as constraints)</span>
<a name="l00178"></a>00178 <span class="comment"> * @param I a feasible integer solution if it exists, else NULL. Allocated if</span>
<a name="l00179"></a>00179 <span class="comment"> * initially set to NULL, else reused.</span>
<a name="l00180"></a>00180 <span class="comment"> */</span>
<a name="l00181"></a><a class="code" href="compress__parms_8h.html#a70ce0c696b3509b89996e7bd8baf6b66">00181</a> <span class="keywordtype">void</span> <a class="code" href="compress__parms_8c.html#a0395c4623907612a51219536d4d258e6" title="Given a system of equalities, looks if it has an integer solution in the combined space...">Equalities_integerSolution</a>(<a class="code" href="structmatrix.html">Matrix</a> * Eqs, <a class="code" href="structmatrix.html">Matrix</a> **I) {
<a name="l00182"></a>00182   <a class="code" href="structmatrix.html">Matrix</a> * Hm, *H=NULL, *U, *Q, *M=NULL, *C=NULL, *Hi;
<a name="l00183"></a>00183   <a class="code" href="structmatrix.html">Matrix</a> *Ip;
<a name="l00184"></a>00184   <span class="keywordtype">int</span> i;
<a name="l00185"></a>00185   Value mod;
<a name="l00186"></a>00186   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rk;
<a name="l00187"></a>00187   <span class="keywordflow">if</span> (Eqs==NULL){
<a name="l00188"></a>00188     <span class="keywordflow">if</span> ((*I)!=NULL) <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(*I);
<a name="l00189"></a>00189     I = NULL;
<a name="l00190"></a>00190     <span class="keywordflow">return</span>;
<a name="l00191"></a>00191   }
<a name="l00192"></a>00192   <span class="comment">/* we use: AI = C = (Ha 0).Q.I = (Ha 0)(I&#39; 0)^T */</span>
<a name="l00193"></a>00193   <span class="comment">/* with I = Qinv.I&#39; = U.I&#39;*/</span>
<a name="l00194"></a>00194   <span class="comment">/* 1- compute I&#39; = Hainv.(-C) */</span>
<a name="l00195"></a>00195   <span class="comment">/* HYP: the equalities are full-row rank */</span>
<a name="l00196"></a>00196   rk = Eqs-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>;
<a name="l00197"></a>00197   <a class="code" href="matrix__addon_8c.html#a33fec91bb879b7b4dda814ad9d33f41b" title="returns a contiguous submatrix of a matrix.">Matrix_subMatrix</a>(Eqs, 0, 1, rk, Eqs-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>-1, &amp;M);
<a name="l00198"></a>00198   <a class="code" href="matrix_8c.html#adcbe5ee3f0c28fb35aed49f4e1f40f5b">left_hermite</a>(M, &amp;Hm, &amp;Q, &amp;U);
<a name="l00199"></a>00199   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(M);
<a name="l00200"></a>00200   <a class="code" href="matrix__addon_8c.html#a33fec91bb879b7b4dda814ad9d33f41b" title="returns a contiguous submatrix of a matrix.">Matrix_subMatrix</a>(Hm, 0, 0, rk, rk, &amp;H);
<a name="l00201"></a>00201   <span class="keywordflow">if</span> (<a class="code" href="compress__parms_8c.html#a964f66a0f36b5e1d0dea475066c53ca0">dbgCompParmMore</a>) {
<a name="l00202"></a>00202     <a class="code" href="matrix__addon_8h.html#a11468159c7fa7d75fadfa10e2e929fee" title="Polylib matrix addons Mainly, deals with polyhedra represented in implicit form (set of constraints)...">show_matrix</a>(Hm);
<a name="l00203"></a>00203     <a class="code" href="matrix__addon_8h.html#a11468159c7fa7d75fadfa10e2e929fee" title="Polylib matrix addons Mainly, deals with polyhedra represented in implicit form (set of constraints)...">show_matrix</a>(H);
<a name="l00204"></a>00204     <a class="code" href="matrix__addon_8h.html#a11468159c7fa7d75fadfa10e2e929fee" title="Polylib matrix addons Mainly, deals with polyhedra represented in implicit form (set of constraints)...">show_matrix</a>(U);
<a name="l00205"></a>00205   }
<a name="l00206"></a>00206   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(Q);
<a name="l00207"></a>00207   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(Hm);
<a name="l00208"></a>00208   <a class="code" href="matrix__addon_8c.html#a33fec91bb879b7b4dda814ad9d33f41b" title="returns a contiguous submatrix of a matrix.">Matrix_subMatrix</a>(Eqs, 0, Eqs-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>-1, rk, Eqs-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>, &amp;C);
<a name="l00209"></a>00209   <a class="code" href="matrix__addon_8c.html#acbbded0c02e89b1a7b6b08ee3f396986" title="transforms a matrix M into -M">Matrix_oppose</a>(C);
<a name="l00210"></a>00210   Hi = <a class="code" href="matrix_8c.html#ac0b29e1d99a2823ad00b5f2157879d80">Matrix_Alloc</a>(rk, rk+1);
<a name="l00211"></a>00211   <a class="code" href="matrix_8c.html#ae2b2f031eb75c5011091536d7ef4befc">MatInverse</a>(H, Hi);
<a name="l00212"></a>00212   <span class="keywordflow">if</span> (<a class="code" href="compress__parms_8c.html#a964f66a0f36b5e1d0dea475066c53ca0">dbgCompParmMore</a>) {
<a name="l00213"></a>00213     <a class="code" href="matrix__addon_8h.html#a11468159c7fa7d75fadfa10e2e929fee" title="Polylib matrix addons Mainly, deals with polyhedra represented in implicit form (set of constraints)...">show_matrix</a>(C);
<a name="l00214"></a>00214     <a class="code" href="matrix__addon_8h.html#a11468159c7fa7d75fadfa10e2e929fee" title="Polylib matrix addons Mainly, deals with polyhedra represented in implicit form (set of constraints)...">show_matrix</a>(Hi);
<a name="l00215"></a>00215   }
<a name="l00216"></a>00216   <span class="comment">/* put the numerator of Hinv back into H */</span>
<a name="l00217"></a>00217   <a class="code" href="matrix__addon_8c.html#a33fec91bb879b7b4dda814ad9d33f41b" title="returns a contiguous submatrix of a matrix.">Matrix_subMatrix</a>(Hi, 0, 0, rk, rk, &amp;H);
<a name="l00218"></a>00218   Ip = <a class="code" href="matrix_8c.html#ac0b29e1d99a2823ad00b5f2157879d80">Matrix_Alloc</a>(Eqs-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>-2, 1);
<a name="l00219"></a>00219   <span class="comment">/* fool Matrix_Product on the size of Ip */</span>
<a name="l00220"></a>00220   Ip-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a> = rk;
<a name="l00221"></a>00221   <a class="code" href="matrix_8c.html#a1e967c74adaa2eec868fd737a55b6624">Matrix_Product</a>(H, C, Ip);
<a name="l00222"></a>00222   Ip-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a> = Eqs-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>-2;
<a name="l00223"></a>00223   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(H);
<a name="l00224"></a>00224   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(C);
<a name="l00225"></a>00225   <a class="code" href="arithmetique_8h.html#af71a2ca0294a19cff0cdcbdcc052ee27">value_init</a>(mod);
<a name="l00226"></a>00226   <span class="keywordflow">for</span> (i=0; i&lt; rk; i++) {
<a name="l00227"></a>00227     <span class="comment">/* if Hinv.C is not integer, return NULL (no solution) */</span>
<a name="l00228"></a>00228     <a class="code" href="arithmetique_8h.html#a60a1720f53f9951170f929062609ddcf">value_pmodulus</a>(mod, Ip-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][0], Hi-&gt;p[i][rk]);
<a name="l00229"></a>00229     <span class="keywordflow">if</span> (<a class="code" href="arithmetique_8h.html#a47d32925340d2dc99ef2d4215080a60d">value_notzero_p</a>(mod)) { 
<a name="l00230"></a>00230       <span class="keywordflow">if</span> ((*I)!=NULL) <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(*I);
<a name="l00231"></a>00231       <a class="code" href="arithmetique_8h.html#ab9b282921e85a0527d462d331533d619">value_clear</a>(mod);
<a name="l00232"></a>00232       <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(U);
<a name="l00233"></a>00233       <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(Ip);
<a name="l00234"></a>00234       <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(Hi);
<a name="l00235"></a>00235       I = NULL;
<a name="l00236"></a>00236       <span class="keywordflow">return</span>;
<a name="l00237"></a>00237     }
<a name="l00238"></a>00238     <span class="keywordflow">else</span> {
<a name="l00239"></a>00239       <a class="code" href="arithmetique_8h.html#a1d5fd16549d53f259c2e7699a22045cb">value_pdivision</a>(Ip-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][0], Ip-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][0], Hi-&gt;p[i][rk]);
<a name="l00240"></a>00240     }
<a name="l00241"></a>00241   }
<a name="l00242"></a>00242   <span class="comment">/* fill the rest of I&#39; with zeros */</span>
<a name="l00243"></a>00243   <span class="keywordflow">for</span> (i=rk; i&lt; Eqs-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>-2; i++) {
<a name="l00244"></a>00244     <a class="code" href="arithmetique_8h.html#a8cc56567a4a29271559ac0fd5f6c5bfa">value_set_si</a>(Ip-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][0], 0);
<a name="l00245"></a>00245   }
<a name="l00246"></a>00246   <a class="code" href="arithmetique_8h.html#ab9b282921e85a0527d462d331533d619">value_clear</a>(mod);
<a name="l00247"></a>00247   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(Hi);
<a name="l00248"></a>00248   <span class="comment">/* 2 - Compute the particular solution I = U.(I&#39; 0) */</span>
<a name="l00249"></a>00249   <a class="code" href="matrix__addon_8h.html#a4f34dad95751e0142b7b9404fc44d0f0" title="Allocates a matrix if it is null, or else asserts that it has at least a certain size.">ensureMatrix</a>((*I), Eqs-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>-2, 1);
<a name="l00250"></a>00250   <a class="code" href="matrix_8c.html#a1e967c74adaa2eec868fd737a55b6624">Matrix_Product</a>(U, Ip, (*I));
<a name="l00251"></a>00251   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(U);
<a name="l00252"></a>00252   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(Ip);
<a name="l00253"></a>00253   <span class="keywordflow">if</span> (<a class="code" href="compress__parms_8c.html#a22fb119bf6f583cf5b74c2bddaa53e70" title="debug flags (2 levels)">dbgCompParm</a>) {
<a name="l00254"></a>00254     <a class="code" href="matrix__addon_8h.html#a11468159c7fa7d75fadfa10e2e929fee" title="Polylib matrix addons Mainly, deals with polyhedra represented in implicit form (set of constraints)...">show_matrix</a>(*I);
<a name="l00255"></a>00255   }
<a name="l00256"></a>00256 }
<a name="l00257"></a>00257 
<a name="l00258"></a>00258 <span class="comment"></span>
<a name="l00259"></a>00259 <span class="comment">/** </span>
<a name="l00260"></a>00260 <span class="comment"> * Computes the validity lattice of a set of equalities. I.e., the lattice</span>
<a name="l00261"></a>00261 <span class="comment"> * induced on the last &lt;tt&gt;b&lt;/tt&gt; variables by the equalities involving the</span>
<a name="l00262"></a>00262 <span class="comment"> * first &lt;tt&gt;a&lt;/tt&gt; integer existential variables.  The submatrix of Eqs that</span>
<a name="l00263"></a>00263 <span class="comment"> * concerns only the existential variables (so the first a columns) is assumed</span>
<a name="l00264"></a>00264 <span class="comment"> * to be full-row rank.</span>
<a name="l00265"></a>00265 <span class="comment"> * @param Eqs the equalities</span>
<a name="l00266"></a>00266 <span class="comment"> * @param a the number of existential integer variables, placed as first</span>
<a name="l00267"></a>00267 <span class="comment"> * variables</span>
<a name="l00268"></a>00268 <span class="comment"> * @param vl the (returned) validity lattice, in homogeneous form. It is</span>
<a name="l00269"></a>00269 <span class="comment"> * allocated if initially set to null, or reused if already allocated.</span>
<a name="l00270"></a>00270 <span class="comment"> */</span>
<a name="l00271"></a><a class="code" href="compress__parms_8h.html#ae018fc28835ce2d99a74dba09055acc0">00271</a> <span class="keywordtype">void</span> <a class="code" href="compress__parms_8c.html#ae018fc28835ce2d99a74dba09055acc0" title="Computes the validity lattice of a set of equalities.">Equalities_validityLattice</a>(<a class="code" href="structmatrix.html">Matrix</a> * Eqs, <span class="keywordtype">int</span> a, <a class="code" href="structmatrix.html">Matrix</a>** vl) {
<a name="l00272"></a>00272   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> b = Eqs-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>-2-a;
<a name="l00273"></a>00273   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> r = Eqs-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>;
<a name="l00274"></a>00274   <a class="code" href="structmatrix.html">Matrix</a> * A=NULL, * B=NULL, *I = NULL, *Lb=NULL, *sol=NULL;
<a name="l00275"></a>00275   <a class="code" href="structmatrix.html">Matrix</a> *H, *U, *Q;
<a name="l00276"></a>00276   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l00277"></a>00277 
<a name="l00278"></a>00278   <span class="keywordflow">if</span> (<a class="code" href="compress__parms_8c.html#a22fb119bf6f583cf5b74c2bddaa53e70" title="debug flags (2 levels)">dbgCompParm</a>) {
<a name="l00279"></a>00279     printf(<span class="stringliteral">&quot;Computing validity lattice induced by the %d first variables of:&quot;</span>
<a name="l00280"></a>00280            ,a);
<a name="l00281"></a>00281     <a class="code" href="matrix__addon_8h.html#a11468159c7fa7d75fadfa10e2e929fee" title="Polylib matrix addons Mainly, deals with polyhedra represented in implicit form (set of constraints)...">show_matrix</a>(Eqs);
<a name="l00282"></a>00282   }
<a name="l00283"></a>00283   <span class="keywordflow">if</span> (b==0) {
<a name="l00284"></a>00284     <a class="code" href="matrix__addon_8h.html#a4f34dad95751e0142b7b9404fc44d0f0" title="Allocates a matrix if it is null, or else asserts that it has at least a certain size.">ensureMatrix</a>((*vl), 1, 1);
<a name="l00285"></a>00285     <a class="code" href="arithmetique_8h.html#a8cc56567a4a29271559ac0fd5f6c5bfa">value_set_si</a>((*vl)-&gt;p[0][0], 1);
<a name="l00286"></a>00286     <span class="keywordflow">return</span>;
<a name="l00287"></a>00287   }
<a name="l00288"></a>00288 
<a name="l00289"></a>00289   <span class="comment">/* 1- check that there is an integer solution to the equalities */</span>
<a name="l00290"></a>00290   <span class="comment">/* OPT: could change integerSolution&#39;s profile to allocate or not*/</span>
<a name="l00291"></a>00291   <a class="code" href="compress__parms_8c.html#a0395c4623907612a51219536d4d258e6" title="Given a system of equalities, looks if it has an integer solution in the combined space...">Equalities_integerSolution</a>(Eqs, &amp;sol);
<a name="l00292"></a>00292   <span class="comment">/* if there is no integer solution, there is no validity lattice */</span>
<a name="l00293"></a>00293   <span class="keywordflow">if</span> (sol==NULL) {
<a name="l00294"></a>00294     <span class="keywordflow">if</span> ((*vl)!=NULL) <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(*vl);
<a name="l00295"></a>00295     <span class="keywordflow">return</span>;
<a name="l00296"></a>00296   }
<a name="l00297"></a>00297   <a class="code" href="matrix__addon_8c.html#a33fec91bb879b7b4dda814ad9d33f41b" title="returns a contiguous submatrix of a matrix.">Matrix_subMatrix</a>(Eqs, 0, 1, r, 1+a, &amp;A);
<a name="l00298"></a>00298   <a class="code" href="matrix__addon_8c.html#a33fec91bb879b7b4dda814ad9d33f41b" title="returns a contiguous submatrix of a matrix.">Matrix_subMatrix</a>(Eqs, 0, 1+a, r, 1+a+b, &amp;B);
<a name="l00299"></a>00299   <a class="code" href="compress__parms_8c.html#a8b044a0b5721eb247eb671644b80df9d" title="Computes the intersection of two linear lattices, whose base vectors are respectively represented in ...">linearInter</a>(A, B, &amp;I, &amp;Lb);
<a name="l00300"></a>00300   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(A);
<a name="l00301"></a>00301   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(B);
<a name="l00302"></a>00302   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(I);
<a name="l00303"></a>00303   <span class="keywordflow">if</span> (<a class="code" href="compress__parms_8c.html#a22fb119bf6f583cf5b74c2bddaa53e70" title="debug flags (2 levels)">dbgCompParm</a>) {
<a name="l00304"></a>00304     <a class="code" href="matrix__addon_8h.html#a11468159c7fa7d75fadfa10e2e929fee" title="Polylib matrix addons Mainly, deals with polyhedra represented in implicit form (set of constraints)...">show_matrix</a>(Lb);
<a name="l00305"></a>00305   }
<a name="l00306"></a>00306   
<a name="l00307"></a>00307   <span class="comment">/* 2- The linear part of the validity lattice is the left HNF of Lb */</span>
<a name="l00308"></a>00308   <a class="code" href="matrix_8c.html#adcbe5ee3f0c28fb35aed49f4e1f40f5b">left_hermite</a>(Lb, &amp;H, &amp;Q, &amp;U);
<a name="l00309"></a>00309   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(Lb);
<a name="l00310"></a>00310   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(Q);
<a name="l00311"></a>00311   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(U);
<a name="l00312"></a>00312 
<a name="l00313"></a>00313   <span class="comment">/* 3- build the validity lattice */</span>
<a name="l00314"></a>00314   <a class="code" href="matrix__addon_8h.html#a4f34dad95751e0142b7b9404fc44d0f0" title="Allocates a matrix if it is null, or else asserts that it has at least a certain size.">ensureMatrix</a>((*vl), b+1, b+1);
<a name="l00315"></a>00315   <a class="code" href="matrix__addon_8c.html#acb90cceb8e7a674a3d5796a1402f0c9e" title="Copies a contiguous submatrix of M1 into M2, at the indicated position.">Matrix_copySubMatrix</a>(H, 0, 0, b, b, (*vl), 0,0);
<a name="l00316"></a>00316   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(H);
<a name="l00317"></a>00317   <span class="keywordflow">for</span> (i=0; i&lt; b; i++) {
<a name="l00318"></a>00318     <a class="code" href="arithmetique_8h.html#a864613888dc46f15679aa4f63e468f89">value_assign</a>((*vl)-&gt;p[i][b], sol-&gt;p[0][a+i]);
<a name="l00319"></a>00319   }
<a name="l00320"></a>00320   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(sol);
<a name="l00321"></a>00321   <a class="code" href="vector_8c.html#a27ccb3ea01f3a496bb799fb99e9e3075">Vector_Set</a>((*vl)-&gt;p[b],0, b);
<a name="l00322"></a>00322   <a class="code" href="arithmetique_8h.html#a8cc56567a4a29271559ac0fd5f6c5bfa">value_set_si</a>((*vl)-&gt;p[b][b], 1);
<a name="l00323"></a>00323   
<a name="l00324"></a>00324 } <span class="comment">/* validityLattice */</span>
<a name="l00325"></a>00325 
<a name="l00326"></a>00326 <span class="comment"></span>
<a name="l00327"></a>00327 <span class="comment">/**</span>
<a name="l00328"></a>00328 <span class="comment"> * Eliminate the columns corresponding to a list of eliminated parameters.</span>
<a name="l00329"></a>00329 <span class="comment"> * @param M the constraints matrix whose columns are to be removed</span>
<a name="l00330"></a>00330 <span class="comment"> * @param nbVars an offset to be added to the ranks of the variables to be</span>
<a name="l00331"></a>00331 <span class="comment"> * removed</span>
<a name="l00332"></a>00332 <span class="comment"> * @param elimParms the list of ranks of the variables to be removed</span>
<a name="l00333"></a>00333 <span class="comment"> * @param newM (output) the matrix without the removed columns</span>
<a name="l00334"></a>00334 <span class="comment"> */</span>
<a name="l00335"></a><a class="code" href="compress__parms_8h.html#a3efbee2cc61c1cfb2e0b05f3320a2e83">00335</a> <span class="keywordtype">void</span> <a class="code" href="compress__parms_8c.html#a3efbee2cc61c1cfb2e0b05f3320a2e83" title="Eliminate the columns corresponding to a list of eliminated parameters.">Constraints_removeElimCols</a>(<a class="code" href="structmatrix.html">Matrix</a> * M, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbVars, 
<a name="l00336"></a>00336                            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *elimParms, <a class="code" href="structmatrix.html">Matrix</a> ** newM) {
<a name="l00337"></a>00337   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i, j, k;
<a name="l00338"></a>00338   <span class="keywordflow">if</span> (elimParms[0]==0) {
<a name="l00339"></a>00339     <a class="code" href="matrix__addon_8c.html#a8269bc80b6beba6d58a4c5b029f04bbf" title="Cloning function.">Matrix_clone</a>(M, newM);
<a name="l00340"></a>00340     <span class="keywordflow">return</span>;
<a name="l00341"></a>00341   }
<a name="l00342"></a>00342   <span class="keywordflow">if</span> ((*newM)==NULL) {
<a name="l00343"></a>00343     (*newM) = <a class="code" href="matrix_8c.html#ac0b29e1d99a2823ad00b5f2157879d80">Matrix_Alloc</a>(M-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>, M-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a> - elimParms[0]);
<a name="l00344"></a>00344   }
<a name="l00345"></a>00345   <span class="keywordflow">else</span> {
<a name="l00346"></a>00346     <a class="code" href="assert_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a> ((*newM)-&gt;NbColumns==M-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a> - elimParms[0]);
<a name="l00347"></a>00347   }
<a name="l00348"></a>00348   <span class="keywordflow">for</span> (i=0; i&lt; M-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>; i++) {
<a name="l00349"></a>00349     <a class="code" href="arithmetique_8h.html#a864613888dc46f15679aa4f63e468f89">value_assign</a>((*newM)-&gt;p[i][0], M-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][0]); <span class="comment">/* kind of cstr */</span>
<a name="l00350"></a>00350     k=0;
<a name="l00351"></a>00351     <a class="code" href="vector_8c.html#ab6eca9ad03a2f4a60dd79182289e0e0b">Vector_Copy</a>(&amp;(M-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][1]), &amp;((*newM)-&gt;p[i][1]), nbVars);
<a name="l00352"></a>00352     <span class="keywordflow">for</span> (j=0; j&lt; M-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>-2-nbVars; j++) {
<a name="l00353"></a>00353       <span class="keywordflow">if</span> (j!=elimParms[k+1]) {
<a name="l00354"></a>00354         <a class="code" href="arithmetique_8h.html#a864613888dc46f15679aa4f63e468f89">value_assign</a>((*newM)-&gt;p[i][j-k+nbVars+1], M-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][j+nbVars+1]);
<a name="l00355"></a>00355       }
<a name="l00356"></a>00356       <span class="keywordflow">else</span> {
<a name="l00357"></a>00357         k++;
<a name="l00358"></a>00358       }
<a name="l00359"></a>00359     }
<a name="l00360"></a>00360     <a class="code" href="arithmetique_8h.html#a864613888dc46f15679aa4f63e468f89">value_assign</a>((*newM)-&gt;p[i][(*newM)-&gt;NbColumns-1], 
<a name="l00361"></a>00361                  M-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][M-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>-1]); <span class="comment">/* cst part */</span>
<a name="l00362"></a>00362   }
<a name="l00363"></a>00363 } <span class="comment">/* Constraints_removeElimCols */</span>
<a name="l00364"></a>00364 
<a name="l00365"></a>00365 <span class="comment"></span>
<a name="l00366"></a>00366 <span class="comment">/**</span>
<a name="l00367"></a>00367 <span class="comment"> * Eliminates all the equalities in a set of constraints and returns the set of</span>
<a name="l00368"></a>00368 <span class="comment"> * constraints defining a full-dimensional polyhedron, such that there is a</span>
<a name="l00369"></a>00369 <span class="comment"> * bijection between integer points of the original polyhedron and these of the</span>
<a name="l00370"></a>00370 <span class="comment"> * resulting (projected) polyhedron).</span>
<a name="l00371"></a>00371 <span class="comment"> * If VL is set to NULL, this funciton allocates it. Else, it assumes that</span>
<a name="l00372"></a>00372 <span class="comment"> * (*VL) points to a matrix of the right size.</span>
<a name="l00373"></a>00373 <span class="comment"> * &lt;p&gt; The following things are done: </span>
<a name="l00374"></a>00374 <span class="comment"> * &lt;ol&gt;</span>
<a name="l00375"></a>00375 <span class="comment"> * &lt;li&gt; remove equalities involving only parameters, and remove as many</span>
<a name="l00376"></a>00376 <span class="comment"> *      parameters as there are such equalities. From that, the list of</span>
<a name="l00377"></a>00377 <span class="comment"> *      eliminated parameters &lt;i&gt;elimParms&lt;/i&gt; is built.</span>
<a name="l00378"></a>00378 <span class="comment"> * &lt;li&gt; remove equalities that involve variables. This requires a compression</span>
<a name="l00379"></a>00379 <span class="comment"> *      of the parameters and of the other variables that are not eliminated.</span>
<a name="l00380"></a>00380 <span class="comment"> *      The affine compresson is represented by matrix VL (for &lt;i&gt;validity</span>
<a name="l00381"></a>00381 <span class="comment"> *      lattice&lt;/i&gt;) and is such that (N I 1)^T = VL.(N&#39; I&#39; 1), where N&#39;, I&#39;</span>
<a name="l00382"></a>00382 <span class="comment"> *      are integer (they are the parameters and variables after compression).</span>
<a name="l00383"></a>00383 <span class="comment"> *&lt;/ol&gt;</span>
<a name="l00384"></a>00384 <span class="comment"> *&lt;/p&gt;</span>
<a name="l00385"></a>00385 <span class="comment"> */</span>
<a name="l00386"></a><a class="code" href="compress__parms_8h.html#a1a9cd66aec30116cfd3b07c2e38c73c8">00386</a> <span class="keywordtype">void</span> <a class="code" href="compress__parms_8c.html#a1a9cd66aec30116cfd3b07c2e38c73c8" title="Eliminates all the equalities in a set of constraints and returns the set of constraints defining a f...">Constraints_fullDimensionize</a>(<a class="code" href="structmatrix.html">Matrix</a> ** M, <a class="code" href="structmatrix.html">Matrix</a> ** C, <a class="code" href="structmatrix.html">Matrix</a> ** VL, 
<a name="l00387"></a>00387                                   <a class="code" href="structmatrix.html">Matrix</a> ** Eqs, <a class="code" href="structmatrix.html">Matrix</a> ** ParmEqs, 
<a name="l00388"></a>00388                                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ** elimVars, 
<a name="l00389"></a>00389                                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ** elimParms,
<a name="l00390"></a>00390                                   <span class="keywordtype">int</span> <a class="code" href="testCompressParms_8c.html#a508eb31b6faa4939e1c32adaef41b8c8">maxRays</a>) {
<a name="l00391"></a>00391   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i, j;
<a name="l00392"></a>00392   <a class="code" href="structmatrix.html">Matrix</a> * A=NULL, *B=NULL;
<a name="l00393"></a>00393   <a class="code" href="structmatrix.html">Matrix</a> * Ineqs=NULL;
<a name="l00394"></a>00394   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbVars = (*M)-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a> - (*C)-&gt;NbColumns;
<a name="l00395"></a>00395   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbParms;
<a name="l00396"></a>00396   <span class="keywordtype">int</span> nbElimVars;
<a name="l00397"></a>00397   <a class="code" href="structmatrix.html">Matrix</a> * fullDim = NULL;
<a name="l00398"></a>00398 
<a name="l00399"></a>00399   <span class="comment">/* variables for permutations */</span>
<a name="l00400"></a>00400   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> * permutation;
<a name="l00401"></a>00401   <a class="code" href="structmatrix.html">Matrix</a> * permutedEqs=NULL, * permutedIneqs=NULL;
<a name="l00402"></a>00402   
<a name="l00403"></a>00403   <span class="comment">/* 1- Eliminate the equalities involving only parameters. */</span>
<a name="l00404"></a>00404   (*ParmEqs) = <a class="code" href="compress__parms_8h.html#a374fb10257b4bbe7a650cff3945e338f">Constraints_removeParmEqs</a>(M, C, 0, elimParms);
<a name="l00405"></a>00405   <span class="comment">/* if the polyehdron is empty, return now. */</span>
<a name="l00406"></a>00406   <span class="keywordflow">if</span> ((*M)-&gt;NbColumns==0) <span class="keywordflow">return</span>;
<a name="l00407"></a>00407   <span class="comment">/* eliminate the columns corresponding to the eliminated parameters */</span>
<a name="l00408"></a>00408   <span class="keywordflow">if</span> (elimParms[0]!=0) {
<a name="l00409"></a>00409     <a class="code" href="compress__parms_8c.html#a3efbee2cc61c1cfb2e0b05f3320a2e83" title="Eliminate the columns corresponding to a list of eliminated parameters.">Constraints_removeElimCols</a>(*M, nbVars, (*elimParms), &amp;A);
<a name="l00410"></a>00410     <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(*M);
<a name="l00411"></a>00411     (*M) = A;
<a name="l00412"></a>00412     <a class="code" href="compress__parms_8c.html#a3efbee2cc61c1cfb2e0b05f3320a2e83" title="Eliminate the columns corresponding to a list of eliminated parameters.">Constraints_removeElimCols</a>(*C, 0, (*elimParms), &amp;B);
<a name="l00413"></a>00413     <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(*C);
<a name="l00414"></a>00414     (*C) = B;
<a name="l00415"></a>00415     <span class="keywordflow">if</span> (<a class="code" href="compress__parms_8c.html#a22fb119bf6f583cf5b74c2bddaa53e70" title="debug flags (2 levels)">dbgCompParm</a>) {
<a name="l00416"></a>00416       printf(<span class="stringliteral">&quot;After false parameter elimination: \n&quot;</span>);
<a name="l00417"></a>00417       <a class="code" href="matrix__addon_8h.html#a11468159c7fa7d75fadfa10e2e929fee" title="Polylib matrix addons Mainly, deals with polyhedra represented in implicit form (set of constraints)...">show_matrix</a>(*M);
<a name="l00418"></a>00418       <a class="code" href="matrix__addon_8h.html#a11468159c7fa7d75fadfa10e2e929fee" title="Polylib matrix addons Mainly, deals with polyhedra represented in implicit form (set of constraints)...">show_matrix</a>(*C);
<a name="l00419"></a>00419     }
<a name="l00420"></a>00420   }
<a name="l00421"></a>00421   nbParms = (*C)-&gt;NbColumns-2;
<a name="l00422"></a>00422 
<a name="l00423"></a>00423   <span class="comment">/* 2- Eliminate the equalities involving variables */</span>
<a name="l00424"></a>00424   <span class="comment">/*   a- extract the (remaining) equalities from the poyhedron */</span>
<a name="l00425"></a>00425   <a class="code" href="matrix__addon_8c.html#a288db1ffeb5425aada82cabf5c824bc4" title="splits a matrix of constraints M into a matrix of equalities Eqs and a matrix of inequalities Ineqs a...">split_constraints</a>((*M), Eqs, &amp;Ineqs);
<a name="l00426"></a>00426   nbElimVars = (*Eqs)-&gt;NbRows;
<a name="l00427"></a>00427   <span class="comment">/*    if the polyhedron is already full-dimensional, return */</span>
<a name="l00428"></a>00428   <span class="keywordflow">if</span> ((*Eqs)-&gt;NbRows==0) {
<a name="l00429"></a>00429     <a class="code" href="matrix__addon_8c.html#adb1631ef2ddb3b386742b881b30f8ce6" title="returns the dim-dimensional identity matrix.">Matrix_identity</a>(nbParms+1, VL);
<a name="l00430"></a>00430     <span class="keywordflow">return</span>;
<a name="l00431"></a>00431   }
<a name="l00432"></a>00432   <span class="comment">/*   b- choose variables to be eliminated */</span>
<a name="l00433"></a>00433   permutation = <a class="code" href="matrix__permutations_8c.html#af43c186b57b2df6caa02a812c175a4d1" title="finds a valid permutation : for a set of m equations, find m variables that will be put at the beginn...">find_a_permutation</a>((*Eqs), nbParms);
<a name="l00434"></a>00434 
<a name="l00435"></a>00435   <span class="keywordflow">if</span> (<a class="code" href="compress__parms_8c.html#a22fb119bf6f583cf5b74c2bddaa53e70" title="debug flags (2 levels)">dbgCompParm</a>) {
<a name="l00436"></a>00436     printf(<span class="stringliteral">&quot;Permuting the vars/parms this way: [ &quot;</span>);
<a name="l00437"></a>00437     <span class="keywordflow">for</span> (i=0; i&lt; (*Eqs)-&gt;NbColumns-2; i++) {
<a name="l00438"></a>00438       printf(<span class="stringliteral">&quot;%d &quot;</span>, permutation[i]);
<a name="l00439"></a>00439     }
<a name="l00440"></a>00440     printf(<span class="stringliteral">&quot;]\n&quot;</span>);
<a name="l00441"></a>00441   }
<a name="l00442"></a>00442 
<a name="l00443"></a>00443   <a class="code" href="matrix__permutations_8c.html#a1714c230c3b1785a1da3c38bcbf7e661" title="permutes the variables of the constraints of a polyhedron">Constraints_permute</a>((*Eqs), permutation, &amp;permutedEqs);
<a name="l00444"></a>00444   <a class="code" href="compress__parms_8c.html#ae018fc28835ce2d99a74dba09055acc0" title="Computes the validity lattice of a set of equalities.">Equalities_validityLattice</a>(permutedEqs, (*Eqs)-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>, VL);
<a name="l00445"></a>00445 
<a name="l00446"></a>00446   <span class="keywordflow">if</span> (<a class="code" href="compress__parms_8c.html#a22fb119bf6f583cf5b74c2bddaa53e70" title="debug flags (2 levels)">dbgCompParm</a>) {
<a name="l00447"></a>00447     printf(<span class="stringliteral">&quot;Validity lattice: &quot;</span>);
<a name="l00448"></a>00448     <a class="code" href="matrix__addon_8h.html#a11468159c7fa7d75fadfa10e2e929fee" title="Polylib matrix addons Mainly, deals with polyhedra represented in implicit form (set of constraints)...">show_matrix</a>(*VL);
<a name="l00449"></a>00449   }
<a name="l00450"></a>00450   <a class="code" href="matrix__addon_8h.html#a9af03fc1d2667573752d7e593d8a50c3">Constraints_compressLastVars</a>(permutedEqs, (*VL));
<a name="l00451"></a>00451   <a class="code" href="matrix__permutations_8c.html#a1714c230c3b1785a1da3c38bcbf7e661" title="permutes the variables of the constraints of a polyhedron">Constraints_permute</a>(Ineqs, permutation, &amp;permutedIneqs);
<a name="l00452"></a>00452   <span class="keywordflow">if</span> (<a class="code" href="compress__parms_8c.html#a964f66a0f36b5e1d0dea475066c53ca0">dbgCompParmMore</a>) {
<a name="l00453"></a>00453     <a class="code" href="matrix__addon_8h.html#a11468159c7fa7d75fadfa10e2e929fee" title="Polylib matrix addons Mainly, deals with polyhedra represented in implicit form (set of constraints)...">show_matrix</a>(permutedIneqs);
<a name="l00454"></a>00454     <a class="code" href="matrix__addon_8h.html#a11468159c7fa7d75fadfa10e2e929fee" title="Polylib matrix addons Mainly, deals with polyhedra represented in implicit form (set of constraints)...">show_matrix</a>(permutedEqs);
<a name="l00455"></a>00455   }
<a name="l00456"></a>00456   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(*Eqs);
<a name="l00457"></a>00457   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(Ineqs);
<a name="l00458"></a>00458   <a class="code" href="matrix__addon_8h.html#a9af03fc1d2667573752d7e593d8a50c3">Constraints_compressLastVars</a>(permutedIneqs, (*VL));
<a name="l00459"></a>00459   <span class="keywordflow">if</span> (<a class="code" href="compress__parms_8c.html#a22fb119bf6f583cf5b74c2bddaa53e70" title="debug flags (2 levels)">dbgCompParm</a>) {
<a name="l00460"></a>00460     printf(<span class="stringliteral">&quot;After compression: &quot;</span>);
<a name="l00461"></a>00461     <a class="code" href="matrix__addon_8h.html#a11468159c7fa7d75fadfa10e2e929fee" title="Polylib matrix addons Mainly, deals with polyhedra represented in implicit form (set of constraints)...">show_matrix</a>(permutedIneqs);
<a name="l00462"></a>00462   }
<a name="l00463"></a>00463   <span class="comment">/*   c- eliminate the first variables */</span>
<a name="l00464"></a>00464   <a class="code" href="assert_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a>(<a class="code" href="matrix__addon_8h.html#af4e227a2b50484a6befcc1e33933eb3a">Constraints_eliminateFirstVars</a>(permutedEqs, permutedIneqs));
<a name="l00465"></a>00465   <span class="keywordflow">if</span> (<a class="code" href="compress__parms_8c.html#a964f66a0f36b5e1d0dea475066c53ca0">dbgCompParmMore</a>) {
<a name="l00466"></a>00466     printf(<span class="stringliteral">&quot;After elimination of the variables: &quot;</span>);
<a name="l00467"></a>00467     <a class="code" href="matrix__addon_8h.html#a11468159c7fa7d75fadfa10e2e929fee" title="Polylib matrix addons Mainly, deals with polyhedra represented in implicit form (set of constraints)...">show_matrix</a>(permutedIneqs);
<a name="l00468"></a>00468   }
<a name="l00469"></a>00469 
<a name="l00470"></a>00470   <span class="comment">/*   d- get rid of the first (zero) columns, </span>
<a name="l00471"></a>00471 <span class="comment">       which are now useless, and put the parameters back at the end */</span>
<a name="l00472"></a>00472   fullDim = <a class="code" href="matrix_8c.html#ac0b29e1d99a2823ad00b5f2157879d80">Matrix_Alloc</a>(permutedIneqs-&gt;NbRows,
<a name="l00473"></a>00473                          permutedIneqs-&gt;NbColumns-nbElimVars);
<a name="l00474"></a>00474   <span class="keywordflow">for</span> (i=0; i&lt; permutedIneqs-&gt;NbRows; i++) {
<a name="l00475"></a>00475     <a class="code" href="arithmetique_8h.html#a8cc56567a4a29271559ac0fd5f6c5bfa">value_set_si</a>(fullDim-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][0], 1);
<a name="l00476"></a>00476     <span class="keywordflow">for</span> (j=0; j&lt; nbParms; j++) {
<a name="l00477"></a>00477       <a class="code" href="arithmetique_8h.html#a864613888dc46f15679aa4f63e468f89">value_assign</a>(fullDim-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][j+fullDim-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>-nbParms-1], 
<a name="l00478"></a>00478                    permutedIneqs-&gt;p[i][j+nbElimVars+1]);
<a name="l00479"></a>00479     }
<a name="l00480"></a>00480     <span class="keywordflow">for</span> (j=0; j&lt; permutedIneqs-&gt;NbColumns-nbParms-2-nbElimVars; j++) {
<a name="l00481"></a>00481       <a class="code" href="arithmetique_8h.html#a864613888dc46f15679aa4f63e468f89">value_assign</a>(fullDim-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][j+1], 
<a name="l00482"></a>00482                    permutedIneqs-&gt;p[i][nbElimVars+nbParms+j+1]);
<a name="l00483"></a>00483     }
<a name="l00484"></a>00484     <a class="code" href="arithmetique_8h.html#a864613888dc46f15679aa4f63e468f89">value_assign</a>(fullDim-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][fullDim-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>-1], 
<a name="l00485"></a>00485                  permutedIneqs-&gt;p[i][permutedIneqs-&gt;NbColumns-1]);
<a name="l00486"></a>00486   }
<a name="l00487"></a>00487   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(permutedIneqs);
<a name="l00488"></a>00488 
<a name="l00489"></a>00489 } <span class="comment">/* Constraints_fullDimensionize */</span>
<a name="l00490"></a>00490 
<a name="l00491"></a>00491 <span class="comment"></span>
<a name="l00492"></a>00492 <span class="comment">/**</span>
<a name="l00493"></a>00493 <span class="comment"> * Given a matrix that defines a full-dimensional affine lattice, returns the </span>
<a name="l00494"></a>00494 <span class="comment"> * affine sub-lattice spanned in the k first dimensions.</span>
<a name="l00495"></a>00495 <span class="comment"> * Useful for instance when you only look for the parameters&#39; validity lattice.</span>
<a name="l00496"></a>00496 <span class="comment"> * @param lat the original full-dimensional lattice</span>
<a name="l00497"></a>00497 <span class="comment"> * @param subLat the sublattice</span>
<a name="l00498"></a>00498 <span class="comment"> */</span>
<a name="l00499"></a><a class="code" href="compress__parms_8h.html#a9a39676ea22cef575c08911c95badba2">00499</a> <span class="keywordtype">void</span> <a class="code" href="compress__parms_8c.html#a9a39676ea22cef575c08911c95badba2" title="Given a matrix that defines a full-dimensional affine lattice, returns the affine sub-lattice spanned...">Lattice_extractSubLattice</a>(<a class="code" href="structmatrix.html">Matrix</a> * lat, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k, <a class="code" href="structmatrix.html">Matrix</a> ** subLat) {
<a name="l00500"></a>00500   <a class="code" href="structmatrix.html">Matrix</a> * H, *Q, *U, *linLat = NULL;
<a name="l00501"></a>00501   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l00502"></a>00502   <a class="code" href="compress__parms_8c.html#a4df7b5873f125cf5c2976bbd4dcfe168">dbgStart</a>(<a class="code" href="compress__parms_8c.html#a9a39676ea22cef575c08911c95badba2" title="Given a matrix that defines a full-dimensional affine lattice, returns the affine sub-lattice spanned...">Lattice_extractSubLattice</a>);
<a name="l00503"></a>00503   <span class="comment">/* if the dimension is already good, just copy the initial lattice */</span>
<a name="l00504"></a>00504   <span class="keywordflow">if</span> (k==lat-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>-1) {
<a name="l00505"></a>00505     <span class="keywordflow">if</span> (*subLat==NULL) {
<a name="l00506"></a>00506       (*subLat) = <a class="code" href="Matop_8c.html#a9d027e9fc6b85e6fa37fc284bf1b5e06">Matrix_Copy</a>(lat);
<a name="l00507"></a>00507     }
<a name="l00508"></a>00508     <span class="keywordflow">else</span> {
<a name="l00509"></a>00509       <a class="code" href="matrix__addon_8c.html#acb90cceb8e7a674a3d5796a1402f0c9e" title="Copies a contiguous submatrix of M1 into M2, at the indicated position.">Matrix_copySubMatrix</a>(lat, 0, 0, lat-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>, lat-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>, (*subLat), 0, 0);
<a name="l00510"></a>00510     }
<a name="l00511"></a>00511     <span class="keywordflow">return</span>;
<a name="l00512"></a>00512   }
<a name="l00513"></a>00513   <a class="code" href="assert_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a>(k&lt;lat-&gt;NbRows-1);
<a name="l00514"></a>00514   <span class="comment">/* 1- Make the linear part of the lattice triangular to eliminate terms from </span>
<a name="l00515"></a>00515 <span class="comment">     other dimensions */</span>
<a name="l00516"></a>00516   <a class="code" href="matrix__addon_8c.html#a33fec91bb879b7b4dda814ad9d33f41b" title="returns a contiguous submatrix of a matrix.">Matrix_subMatrix</a>(lat, 0, 0, lat-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>, lat-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>-1, &amp;linLat);
<a name="l00517"></a>00517   <span class="comment">/* OPT: any integer column-vector elimination is ok indeed. */</span>
<a name="l00518"></a>00518   <span class="comment">/* OPT: could test if the lattice is already in triangular form. */</span>
<a name="l00519"></a>00519   <a class="code" href="matrix_8c.html#adcbe5ee3f0c28fb35aed49f4e1f40f5b">left_hermite</a>(linLat, &amp;H, &amp;Q, &amp;U);
<a name="l00520"></a>00520   <span class="keywordflow">if</span> (<a class="code" href="compress__parms_8c.html#a964f66a0f36b5e1d0dea475066c53ca0">dbgCompParmMore</a>) {
<a name="l00521"></a>00521     <a class="code" href="matrix__addon_8h.html#a11468159c7fa7d75fadfa10e2e929fee" title="Polylib matrix addons Mainly, deals with polyhedra represented in implicit form (set of constraints)...">show_matrix</a>(H);
<a name="l00522"></a>00522   }
<a name="l00523"></a>00523   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(Q);
<a name="l00524"></a>00524   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(U);
<a name="l00525"></a>00525   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(linLat);
<a name="l00526"></a>00526   <span class="comment">/* if not allocated yet, allocate it */</span>
<a name="l00527"></a>00527   <span class="keywordflow">if</span> (*subLat==NULL) {
<a name="l00528"></a>00528     (*subLat) = <a class="code" href="matrix_8c.html#ac0b29e1d99a2823ad00b5f2157879d80">Matrix_Alloc</a>(k+1, k+1);
<a name="l00529"></a>00529   }
<a name="l00530"></a>00530   <a class="code" href="matrix__addon_8c.html#acb90cceb8e7a674a3d5796a1402f0c9e" title="Copies a contiguous submatrix of M1 into M2, at the indicated position.">Matrix_copySubMatrix</a>(H, 0, 0, k, k, (*subLat), 0, 0);
<a name="l00531"></a>00531   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(H);
<a name="l00532"></a>00532   <a class="code" href="matrix__addon_8c.html#acb90cceb8e7a674a3d5796a1402f0c9e" title="Copies a contiguous submatrix of M1 into M2, at the indicated position.">Matrix_copySubMatrix</a>(lat, 0, lat-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>-1, k, 1, (*subLat), 0, k);
<a name="l00533"></a>00533   <span class="keywordflow">for</span> (i=0; i&lt;k; i++) {
<a name="l00534"></a>00534     <a class="code" href="arithmetique_8h.html#a8cc56567a4a29271559ac0fd5f6c5bfa">value_set_si</a>((*subLat)-&gt;p[k][i], 0);
<a name="l00535"></a>00535   }
<a name="l00536"></a>00536   <a class="code" href="arithmetique_8h.html#a8cc56567a4a29271559ac0fd5f6c5bfa">value_set_si</a>((*subLat)-&gt;p[k][k], 1);
<a name="l00537"></a>00537   <a class="code" href="compress__parms_8c.html#a49fcecacd32fa2357935cb5a4f542e0c">dbgEnd</a>(<a class="code" href="compress__parms_8c.html#a9a39676ea22cef575c08911c95badba2" title="Given a matrix that defines a full-dimensional affine lattice, returns the affine sub-lattice spanned...">Lattice_extractSubLattice</a>);
<a name="l00538"></a>00538 } <span class="comment">/* Lattice_extractSubLattice */</span>
<a name="l00539"></a>00539 
<a name="l00540"></a>00540 <span class="comment"></span>
<a name="l00541"></a>00541 <span class="comment">/** </span>
<a name="l00542"></a>00542 <span class="comment"> * Computes the overall period of the variables I for (MI) mod |d|, where M is</span>
<a name="l00543"></a>00543 <span class="comment"> * a matrix and |d| a vector. Produce a diagonal matrix S = (s_k) where s_k is</span>
<a name="l00544"></a>00544 <span class="comment"> * the overall period of i_k </span>
<a name="l00545"></a>00545 <span class="comment"> * @param M the set of affine functions of I (row-vectors)</span>
<a name="l00546"></a>00546 <span class="comment"> * @param d the column-vector representing the modulos</span>
<a name="l00547"></a>00547 <span class="comment">*/</span>
<a name="l00548"></a><a class="code" href="compress__parms_8h.html#abfe5775031fc1fc8b783ef3a248a18b0">00548</a> <a class="code" href="structmatrix.html">Matrix</a> * <a class="code" href="compress__parms_8c.html#abfe5775031fc1fc8b783ef3a248a18b0" title="Computes the overall period of the variables I for (MI) mod |d|, where M is a matrix and |d| a vector...">affine_periods</a>(<a class="code" href="structmatrix.html">Matrix</a> * M, <a class="code" href="structmatrix.html">Matrix</a> * d) {
<a name="l00549"></a>00549   <a class="code" href="structmatrix.html">Matrix</a> * S;
<a name="l00550"></a>00550   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i,j;
<a name="l00551"></a>00551   Value tmp;
<a name="l00552"></a>00552   Value * periods = (Value *)malloc(<span class="keyword">sizeof</span>(Value) * M-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>);
<a name="l00553"></a>00553   <a class="code" href="arithmetique_8h.html#af71a2ca0294a19cff0cdcbdcc052ee27">value_init</a>(tmp);
<a name="l00554"></a>00554   <span class="keywordflow">for</span>(i=0; i&lt; M-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>; i++) {
<a name="l00555"></a>00555     <a class="code" href="arithmetique_8h.html#af71a2ca0294a19cff0cdcbdcc052ee27">value_init</a>(periods[i]);
<a name="l00556"></a>00556     <a class="code" href="arithmetique_8h.html#a8cc56567a4a29271559ac0fd5f6c5bfa">value_set_si</a>(periods[i], 1);
<a name="l00557"></a>00557   }
<a name="l00558"></a>00558   <span class="keywordflow">for</span> (i=0; i&lt;M-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>; i++) {
<a name="l00559"></a>00559     <span class="keywordflow">for</span> (j=0; j&lt; M-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>; j++) {
<a name="l00560"></a>00560       <a class="code" href="arithmetique_8h.html#a50a34e78517e58cd1c2494a99be1e62b">value_gcd</a>(tmp, d-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][0], M-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][j]);
<a name="l00561"></a>00561       <a class="code" href="arithmetique_8h.html#a4b01d50506e0c7691b69d57a87280f5d">value_divexact</a>(tmp, d-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][0], tmp);
<a name="l00562"></a>00562       <a class="code" href="arithmetique_8h.html#a6da13dbfdd065b7609591ff6b3aee310">value_lcm</a>(periods[j], periods[j], tmp);
<a name="l00563"></a>00563      }
<a name="l00564"></a>00564   }
<a name="l00565"></a>00565   <a class="code" href="arithmetique_8h.html#ab9b282921e85a0527d462d331533d619">value_clear</a>(tmp);
<a name="l00566"></a>00566 
<a name="l00567"></a>00567   <span class="comment">/* 2- build S */</span>
<a name="l00568"></a>00568   S = <a class="code" href="matrix_8c.html#ac0b29e1d99a2823ad00b5f2157879d80">Matrix_Alloc</a>(M-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>, M-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>);
<a name="l00569"></a>00569   <span class="keywordflow">for</span> (i=0; i&lt; M-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>; i++) 
<a name="l00570"></a>00570     <span class="keywordflow">for</span> (j=0; j&lt; M-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>; j++)
<a name="l00571"></a>00571       <span class="keywordflow">if</span> (i==j) <a class="code" href="arithmetique_8h.html#a864613888dc46f15679aa4f63e468f89">value_assign</a>(S-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][j],periods[j]);
<a name="l00572"></a>00572       <span class="keywordflow">else</span> <a class="code" href="arithmetique_8h.html#a8cc56567a4a29271559ac0fd5f6c5bfa">value_set_si</a>(S-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][j], 0);
<a name="l00573"></a>00573 
<a name="l00574"></a>00574   <span class="comment">/* 3- clean up */</span>
<a name="l00575"></a>00575   <span class="keywordflow">for</span>(i=0; i&lt; M-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>; i++) <a class="code" href="arithmetique_8h.html#ab9b282921e85a0527d462d331533d619">value_clear</a>(periods[i]);
<a name="l00576"></a>00576   free(periods);
<a name="l00577"></a>00577   <span class="keywordflow">return</span> S;
<a name="l00578"></a>00578 } <span class="comment">/* affine_periods */</span>
<a name="l00579"></a>00579 
<a name="l00580"></a>00580 <span class="comment"></span>
<a name="l00581"></a>00581 <span class="comment">/** </span>
<a name="l00582"></a>00582 <span class="comment"> * Given an integer matrix B with m rows and integer m-vectors C and d,</span>
<a name="l00583"></a>00583 <span class="comment"> * computes the basis of the integer solutions to (BN+C) mod d = 0 (1).</span>
<a name="l00584"></a>00584 <span class="comment"> * This is an affine lattice (G): (N 1)^T= G(N&#39; 1)^T, forall N&#39; in Z^b.</span>
<a name="l00585"></a>00585 <span class="comment"> * If there is no solution, returns NULL.</span>
<a name="l00586"></a>00586 <span class="comment"> * @param B B, a (m x b) matrix</span>
<a name="l00587"></a>00587 <span class="comment"> * @param C C, a (m x 1) integer matrix</span>
<a name="l00588"></a>00588 <span class="comment"> * @param d d, a (1 x m) integer matrix</span>
<a name="l00589"></a>00589 <span class="comment"> * @param imb the affine (b+1)x(b+1) basis of solutions, in the homogeneous</span>
<a name="l00590"></a>00590 <span class="comment"> * form. Allocated if initially set to NULL, reused if not.</span>
<a name="l00591"></a>00591 <span class="comment">*/</span>
<a name="l00592"></a><a class="code" href="compress__parms_8h.html#a12b7b863af43c3d85682b9df2385938c">00592</a> <span class="keywordtype">void</span> <a class="code" href="compress__parms_8c.html#a12b7b863af43c3d85682b9df2385938c" title="Given an integer matrix B with m rows and integer m-vectors C and d, computes the basis of the intege...">Equalities_intModBasis</a>(<a class="code" href="structmatrix.html">Matrix</a> * B, <a class="code" href="structmatrix.html">Matrix</a> * C, <a class="code" href="structmatrix.html">Matrix</a> * d, <a class="code" href="structmatrix.html">Matrix</a> ** imb) {
<a name="l00593"></a>00593   <span class="keywordtype">int</span> b = B-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>;
<a name="l00594"></a>00594   <span class="comment">/* FIXME: treat the case d=0 as a regular equality B_kN+C_k = 0: */</span>
<a name="l00595"></a>00595   <span class="comment">/* OPT: could keep only equalities for which d&gt;1 */</span>
<a name="l00596"></a>00596   <span class="keywordtype">int</span> nbEqs = B-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>;
<a name="l00597"></a>00597   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l00598"></a>00598 
<a name="l00599"></a>00599   <span class="comment">/* 1- buid the problem DI+BN+C = 0 */</span>
<a name="l00600"></a>00600   <a class="code" href="structmatrix.html">Matrix</a> * eqs = <a class="code" href="matrix_8c.html#ac0b29e1d99a2823ad00b5f2157879d80">Matrix_Alloc</a>(nbEqs, nbEqs+b+1);
<a name="l00601"></a>00601   <span class="keywordflow">for</span> (i=0; i&lt; nbEqs; i++) {
<a name="l00602"></a>00602     <a class="code" href="arithmetique_8h.html#a864613888dc46f15679aa4f63e468f89">value_assign</a>(eqs-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][i], d-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[0][i]);
<a name="l00603"></a>00603   }
<a name="l00604"></a>00604   <a class="code" href="matrix__addon_8c.html#acb90cceb8e7a674a3d5796a1402f0c9e" title="Copies a contiguous submatrix of M1 into M2, at the indicated position.">Matrix_copySubMatrix</a>(B, 0, 0, nbEqs, b, eqs, 0, nbEqs);
<a name="l00605"></a>00605   <a class="code" href="matrix__addon_8c.html#acb90cceb8e7a674a3d5796a1402f0c9e" title="Copies a contiguous submatrix of M1 into M2, at the indicated position.">Matrix_copySubMatrix</a>(C, 0, 0, nbEqs, 1, eqs, 0, nbEqs+b);
<a name="l00606"></a>00606 
<a name="l00607"></a>00607   <span class="comment">/* 2- the solution is the validity lattice of the equalities */</span>
<a name="l00608"></a>00608   <a class="code" href="compress__parms_8c.html#ae018fc28835ce2d99a74dba09055acc0" title="Computes the validity lattice of a set of equalities.">Equalities_validityLattice</a>(eqs, nbEqs, imb);
<a name="l00609"></a>00609   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(eqs);
<a name="l00610"></a>00610 } <span class="comment">/* Equalities_intModBasis */</span>
<a name="l00611"></a>00611 
<a name="l00612"></a>00612 <span class="comment"></span>
<a name="l00613"></a>00613 <span class="comment">/** kept here for backwards compatiblity. Wrapper to Equalities_intModBasis() */</span>
<a name="l00614"></a><a class="code" href="compress__parms_8h.html#afdd668f63e1141067dc0caef3ef03374">00614</a> <a class="code" href="structmatrix.html">Matrix</a> * <a class="code" href="compress__parms_8c.html#a091ae8062b33511134d13b0035a56777" title="kept here for backwards compatiblity.">int_mod_basis</a>(<a class="code" href="structmatrix.html">Matrix</a> * B, <a class="code" href="structmatrix.html">Matrix</a> * C, <a class="code" href="structmatrix.html">Matrix</a> * d) {
<a name="l00615"></a>00615   <a class="code" href="structmatrix.html">Matrix</a> * imb = NULL;
<a name="l00616"></a>00616   <a class="code" href="compress__parms_8c.html#a12b7b863af43c3d85682b9df2385938c" title="Given an integer matrix B with m rows and integer m-vectors C and d, computes the basis of the intege...">Equalities_intModBasis</a>(B, C, d, &amp;imb);
<a name="l00617"></a>00617   <span class="keywordflow">return</span> imb;
<a name="l00618"></a>00618 } <span class="comment">/* int_mod_basis */</span>
<a name="l00619"></a>00619 
<a name="l00620"></a>00620 <span class="comment"></span>
<a name="l00621"></a>00621 <span class="comment">/**</span>
<a name="l00622"></a>00622 <span class="comment"> * Given a parameterized constraints matrix with m equalities, computes the</span>
<a name="l00623"></a>00623 <span class="comment"> * compression matrix G such that there is an integer solution in the variables</span>
<a name="l00624"></a>00624 <span class="comment"> * space for each value of N&#39;, with N = G N&#39; (N are the &quot;nb_parms&quot; parameters)</span>
<a name="l00625"></a>00625 <span class="comment"> * @param E a matrix of parametric equalities @param nb_parms the number of</span>
<a name="l00626"></a>00626 <span class="comment"> * parameters</span>
<a name="l00627"></a>00627 <span class="comment"> * &lt;b&gt;Note: &lt;/b&gt;this function is mostly here for backwards</span>
<a name="l00628"></a>00628 <span class="comment"> * compatibility. Prefer the use of &lt;tt&gt;Equalities_validityLattice&lt;/tt&gt;.</span>
<a name="l00629"></a>00629 <span class="comment">*/</span>
<a name="l00630"></a><a class="code" href="compress__parms_8h.html#a3cec7363dc147b76f23dea6738a10161">00630</a> <a class="code" href="structmatrix.html">Matrix</a> * <a class="code" href="compress__parms_8c.html#a4877b02bfffc51db4d9ac702475c3765" title="Given a parameterized constraints matrix with m equalities, computes the compression matrix G such th...">compress_parms</a>(<a class="code" href="structmatrix.html">Matrix</a> * E, <span class="keywordtype">int</span> nbParms) {
<a name="l00631"></a>00631   <a class="code" href="structmatrix.html">Matrix</a> * vl=NULL;
<a name="l00632"></a>00632   <a class="code" href="compress__parms_8c.html#ae018fc28835ce2d99a74dba09055acc0" title="Computes the validity lattice of a set of equalities.">Equalities_validityLattice</a>(E, E-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>-2-nbParms, &amp;vl);
<a name="l00633"></a>00633   <span class="keywordflow">return</span> vl;
<a name="l00634"></a>00634 }<span class="comment">/* compress_parms */</span>
<a name="l00635"></a>00635 
<a name="l00636"></a>00636 <span class="comment"></span>
<a name="l00637"></a>00637 <span class="comment">/** Removes the equalities that involve only parameters, by eliminating some</span>
<a name="l00638"></a>00638 <span class="comment"> * parameters in the polyhedron&#39;s constraints and in the context.&lt;p&gt; </span>
<a name="l00639"></a>00639 <span class="comment"> * &lt;b&gt;Updates M and Ctxt.&lt;/b&gt;</span>
<a name="l00640"></a>00640 <span class="comment"> * @param M1 the polyhedron&#39;s constraints</span>
<a name="l00641"></a>00641 <span class="comment"> * @param Ctxt1 the constraints of the polyhedron&#39;s context</span>
<a name="l00642"></a>00642 <span class="comment"> * @param renderSpace tells if the returned equalities must be expressed in the</span>
<a name="l00643"></a>00643 <span class="comment"> * parameters space (renderSpace=0) or in the combined var/parms space</span>
<a name="l00644"></a>00644 <span class="comment"> * (renderSpace = 1)</span>
<a name="l00645"></a>00645 <span class="comment"> * @param elimParms the list of parameters that have been removed: an array</span>
<a name="l00646"></a>00646 <span class="comment"> * whose 1st element is the number of elements in the list.  (returned)</span>
<a name="l00647"></a>00647 <span class="comment"> * @return the system of equalities that involve only parameters.</span>
<a name="l00648"></a>00648 <span class="comment"> */</span>
<a name="l00649"></a><a class="code" href="compress__parms_8h.html#a1d7622dc1bb2a0f564af26632797b0d2">00649</a> <a class="code" href="structmatrix.html">Matrix</a> * <a class="code" href="compress__parms_8c.html#aca0035f9313236fd8046ab042180f544" title="Removes the equalities that involve only parameters, by eliminating some parameters in the polyhedron...">Constraints_Remove_parm_eqs</a>(<a class="code" href="structmatrix.html">Matrix</a> ** M1, <a class="code" href="structmatrix.html">Matrix</a> ** Ctxt1, 
<a name="l00650"></a>00650                                      <span class="keywordtype">int</span> renderSpace, 
<a name="l00651"></a>00651                                      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ** elimParms) {
<a name="l00652"></a>00652   <span class="keywordtype">int</span> i, j, k, nbEqsParms =0;
<a name="l00653"></a>00653   <span class="keywordtype">int</span> nbEqsM, nbEqsCtxt, allZeros, nbTautoM = 0, nbTautoCtxt = 0;
<a name="l00654"></a>00654   <a class="code" href="structmatrix.html">Matrix</a> * M = (*M1);
<a name="l00655"></a>00655   <a class="code" href="structmatrix.html">Matrix</a> * Ctxt = (*Ctxt1);
<a name="l00656"></a>00656   <span class="keywordtype">int</span> nbVars = M-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>-Ctxt-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>;
<a name="l00657"></a>00657   <a class="code" href="structmatrix.html">Matrix</a> * Eqs;
<a name="l00658"></a>00658   <a class="code" href="structmatrix.html">Matrix</a> * EqsMTmp;
<a name="l00659"></a>00659   
<a name="l00660"></a>00660   <span class="comment">/* 1- build the equality matrix(ces) */</span>
<a name="l00661"></a>00661   nbEqsM = 0;
<a name="l00662"></a>00662   <span class="keywordflow">for</span> (i=0; i&lt; M-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>; i++) {
<a name="l00663"></a>00663     k = <a class="code" href="vector_8c.html#ab719ec10095622cd0ad8024da53cdd4c">First_Non_Zero</a>(M-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i], M-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>);
<a name="l00664"></a>00664     <span class="comment">/* if it is a tautology, count it as such */</span>
<a name="l00665"></a>00665     <span class="keywordflow">if</span> (k==-1) {
<a name="l00666"></a>00666       nbTautoM++;
<a name="l00667"></a>00667     }
<a name="l00668"></a>00668     <span class="keywordflow">else</span> {
<a name="l00669"></a>00669       <span class="comment">/* if it only involves parameters, count it */</span>
<a name="l00670"></a>00670       <span class="keywordflow">if</span> (k&gt;= nbVars+1) nbEqsM++;
<a name="l00671"></a>00671     }
<a name="l00672"></a>00672   }
<a name="l00673"></a>00673 
<a name="l00674"></a>00674   nbEqsCtxt = 0;
<a name="l00675"></a>00675   <span class="keywordflow">for</span> (i=0; i&lt; Ctxt-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>; i++) {
<a name="l00676"></a>00676     <span class="keywordflow">if</span> (<a class="code" href="arithmetique_8h.html#a827532f2140ae2aa96e46baebae09723">value_zero_p</a>(Ctxt-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][0])) {
<a name="l00677"></a>00677       <span class="keywordflow">if</span> (<a class="code" href="vector_8c.html#ab719ec10095622cd0ad8024da53cdd4c">First_Non_Zero</a>(Ctxt-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i], Ctxt-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>)==-1) {
<a name="l00678"></a>00678         nbTautoCtxt++;
<a name="l00679"></a>00679       }
<a name="l00680"></a>00680       <span class="keywordflow">else</span> {
<a name="l00681"></a>00681         nbEqsCtxt ++;
<a name="l00682"></a>00682       }
<a name="l00683"></a>00683     }
<a name="l00684"></a>00684   }
<a name="l00685"></a>00685   nbEqsParms = nbEqsM + nbEqsCtxt; 
<a name="l00686"></a>00686 
<a name="l00687"></a>00687   <span class="comment">/* nothing to do in this case */</span>
<a name="l00688"></a>00688   <span class="keywordflow">if</span> (nbEqsParms+nbTautoM+nbTautoCtxt==0) {
<a name="l00689"></a>00689     (*elimParms) = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*) malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00690"></a>00690     (*elimParms)[0] = 0;
<a name="l00691"></a>00691     <span class="keywordflow">if</span> (renderSpace==0) {
<a name="l00692"></a>00692       <span class="keywordflow">return</span> <a class="code" href="matrix_8c.html#ac0b29e1d99a2823ad00b5f2157879d80">Matrix_Alloc</a>(0,Ctxt-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>);
<a name="l00693"></a>00693     }
<a name="l00694"></a>00694     <span class="keywordflow">else</span> {
<a name="l00695"></a>00695       <span class="keywordflow">return</span> <a class="code" href="matrix_8c.html#ac0b29e1d99a2823ad00b5f2157879d80">Matrix_Alloc</a>(0,M-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>);
<a name="l00696"></a>00696     }
<a name="l00697"></a>00697   }
<a name="l00698"></a>00698   
<a name="l00699"></a>00699   Eqs= <a class="code" href="matrix_8c.html#ac0b29e1d99a2823ad00b5f2157879d80">Matrix_Alloc</a>(nbEqsParms, Ctxt-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>);
<a name="l00700"></a>00700   EqsMTmp= <a class="code" href="matrix_8c.html#ac0b29e1d99a2823ad00b5f2157879d80">Matrix_Alloc</a>(nbEqsParms, M-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>);
<a name="l00701"></a>00701   
<a name="l00702"></a>00702   <span class="comment">/* copy equalities from the context */</span>
<a name="l00703"></a>00703   k = 0;
<a name="l00704"></a>00704   <span class="keywordflow">for</span> (i=0; i&lt; Ctxt-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>; i++) {
<a name="l00705"></a>00705     <span class="keywordflow">if</span> (<a class="code" href="arithmetique_8h.html#a827532f2140ae2aa96e46baebae09723">value_zero_p</a>(Ctxt-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][0]) 
<a name="l00706"></a>00706                      &amp;&amp; <a class="code" href="vector_8c.html#ab719ec10095622cd0ad8024da53cdd4c">First_Non_Zero</a>(Ctxt-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i], Ctxt-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>)!=-1) {
<a name="l00707"></a>00707       <a class="code" href="vector_8c.html#ab6eca9ad03a2f4a60dd79182289e0e0b">Vector_Copy</a>(Ctxt-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i], Eqs-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[k], Ctxt-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>);
<a name="l00708"></a>00708       <a class="code" href="vector_8c.html#ab6eca9ad03a2f4a60dd79182289e0e0b">Vector_Copy</a>(Ctxt-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i]+1, EqsMTmp-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[k]+nbVars+1, 
<a name="l00709"></a>00709                   Ctxt-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>-1);
<a name="l00710"></a>00710       k++;
<a name="l00711"></a>00711     }
<a name="l00712"></a>00712   }
<a name="l00713"></a>00713   <span class="keywordflow">for</span> (i=0; i&lt; M-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>; i++) {
<a name="l00714"></a>00714     j=<a class="code" href="vector_8c.html#ab719ec10095622cd0ad8024da53cdd4c">First_Non_Zero</a>(M-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i], M-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>);
<a name="l00715"></a>00715     <span class="comment">/* copy equalities that involve only parameters from M */</span>
<a name="l00716"></a>00716     <span class="keywordflow">if</span> (j&gt;=nbVars+1) {
<a name="l00717"></a>00717       <a class="code" href="vector_8c.html#ab6eca9ad03a2f4a60dd79182289e0e0b">Vector_Copy</a>(M-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i]+nbVars+1, Eqs-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[k]+1, Ctxt-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>-1);
<a name="l00718"></a>00718       <a class="code" href="vector_8c.html#ab6eca9ad03a2f4a60dd79182289e0e0b">Vector_Copy</a>(M-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i]+nbVars+1, EqsMTmp-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[k]+nbVars+1, 
<a name="l00719"></a>00719                   Ctxt-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>-1);
<a name="l00720"></a>00720       <span class="comment">/* mark these equalities for removal */</span>
<a name="l00721"></a>00721       <a class="code" href="arithmetique_8h.html#a8cc56567a4a29271559ac0fd5f6c5bfa">value_set_si</a>(M-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][0], 2);
<a name="l00722"></a>00722       k++;
<a name="l00723"></a>00723     }
<a name="l00724"></a>00724     <span class="comment">/* mark the all-zero equalities for removal */</span>
<a name="l00725"></a>00725     <span class="keywordflow">if</span> (j==-1) {
<a name="l00726"></a>00726       <a class="code" href="arithmetique_8h.html#a8cc56567a4a29271559ac0fd5f6c5bfa">value_set_si</a>(M-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][0], 2);
<a name="l00727"></a>00727     }
<a name="l00728"></a>00728   }
<a name="l00729"></a>00729 
<a name="l00730"></a>00730   <span class="comment">/* 2- eliminate parameters until all equalities are used or until we find a</span>
<a name="l00731"></a>00731 <span class="comment">  contradiction (overconstrained system) */</span>
<a name="l00732"></a>00732   (*elimParms) = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *) malloc((Eqs-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>+1) * <span class="keyword">sizeof</span>(int));
<a name="l00733"></a>00733   (*elimParms)[0] = 0;
<a name="l00734"></a>00734   allZeros = 0;
<a name="l00735"></a>00735   <span class="keywordflow">for</span> (i=0; i&lt; Eqs-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>; i++) {
<a name="l00736"></a>00736     <span class="comment">/* find a variable that can be eliminated */</span>
<a name="l00737"></a>00737     k = <a class="code" href="vector_8c.html#ab719ec10095622cd0ad8024da53cdd4c">First_Non_Zero</a>(Eqs-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i], Eqs-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>);
<a name="l00738"></a>00738     <span class="keywordflow">if</span> (k!=-1) { <span class="comment">/* nothing special to do for tautologies */</span>
<a name="l00739"></a>00739 
<a name="l00740"></a>00740       <span class="comment">/* if there is a contradiction, return empty matrices */</span>
<a name="l00741"></a>00741       <span class="keywordflow">if</span> (k==Eqs-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>-1) {
<a name="l00742"></a>00742         printf(<span class="stringliteral">&quot;Contradiction in %dth row of Eqs: &quot;</span>,k);
<a name="l00743"></a>00743         <a class="code" href="matrix__addon_8h.html#a11468159c7fa7d75fadfa10e2e929fee" title="Polylib matrix addons Mainly, deals with polyhedra represented in implicit form (set of constraints)...">show_matrix</a>(Eqs);
<a name="l00744"></a>00744         <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(Eqs);
<a name="l00745"></a>00745         <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(EqsMTmp);
<a name="l00746"></a>00746         (*M1) = <a class="code" href="matrix_8c.html#ac0b29e1d99a2823ad00b5f2157879d80">Matrix_Alloc</a>(0, M-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>);
<a name="l00747"></a>00747         <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(M);
<a name="l00748"></a>00748         (*Ctxt1) = <a class="code" href="matrix_8c.html#ac0b29e1d99a2823ad00b5f2157879d80">Matrix_Alloc</a>(0,Ctxt-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>);
<a name="l00749"></a>00749         <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(Ctxt);
<a name="l00750"></a>00750         free(*elimParms);
<a name="l00751"></a>00751         (*elimParms) = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *) malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00752"></a>00752         (*elimParms)[0] = 0;
<a name="l00753"></a>00753         <span class="keywordflow">if</span> (renderSpace==1) {
<a name="l00754"></a>00754           <span class="keywordflow">return</span> <a class="code" href="matrix_8c.html#ac0b29e1d99a2823ad00b5f2157879d80">Matrix_Alloc</a>(0,(*M1)-&gt;NbColumns);
<a name="l00755"></a>00755         }
<a name="l00756"></a>00756         <span class="keywordflow">else</span> {
<a name="l00757"></a>00757           <span class="keywordflow">return</span> <a class="code" href="matrix_8c.html#ac0b29e1d99a2823ad00b5f2157879d80">Matrix_Alloc</a>(0,(*Ctxt1)-&gt;NbColumns);
<a name="l00758"></a>00758         }
<a name="l00759"></a>00759       } 
<a name="l00760"></a>00760       <span class="comment">/* if we have something we can eliminate, do it in 3 places:</span>
<a name="l00761"></a>00761 <span class="comment">         Eqs, Ctxt, and M */</span>
<a name="l00762"></a>00762       <span class="keywordflow">else</span> {
<a name="l00763"></a>00763         k--; <span class="comment">/* k is the rank of the variable, now */</span>
<a name="l00764"></a>00764         (*elimParms)[0]++;
<a name="l00765"></a>00765         (*elimParms)[(*elimParms[0])]=k;
<a name="l00766"></a>00766         <span class="keywordflow">for</span> (j=0; j&lt; Eqs-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>; j++) {
<a name="l00767"></a>00767           <span class="keywordflow">if</span> (i!=j) {
<a name="l00768"></a>00768             <a class="code" href="matrix__addon_8c.html#a79d19aa329285819b31bc7a602241842" title="use an eliminator row to eliminate a variable in a victim row (without changing the sign of the victi...">eliminate_var_with_constr</a>(Eqs, i, Eqs, j, k);
<a name="l00769"></a>00769             <a class="code" href="matrix__addon_8c.html#a79d19aa329285819b31bc7a602241842" title="use an eliminator row to eliminate a variable in a victim row (without changing the sign of the victi...">eliminate_var_with_constr</a>(EqsMTmp, i, EqsMTmp, j, k+nbVars);
<a name="l00770"></a>00770           }
<a name="l00771"></a>00771         }
<a name="l00772"></a>00772         <span class="keywordflow">for</span> (j=0; j&lt; Ctxt-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>; j++) {
<a name="l00773"></a>00773           <span class="keywordflow">if</span> (<a class="code" href="arithmetique_8h.html#a47d32925340d2dc99ef2d4215080a60d">value_notzero_p</a>(Ctxt-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][0])) {
<a name="l00774"></a>00774             <a class="code" href="matrix__addon_8c.html#a79d19aa329285819b31bc7a602241842" title="use an eliminator row to eliminate a variable in a victim row (without changing the sign of the victi...">eliminate_var_with_constr</a>(Eqs, i, Ctxt, j, k);
<a name="l00775"></a>00775           }
<a name="l00776"></a>00776         }
<a name="l00777"></a>00777         <span class="keywordflow">for</span> (j=0; j&lt; M-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>; j++) {
<a name="l00778"></a>00778           <span class="keywordflow">if</span> (<a class="code" href="arithmetique_8h.html#afee537d2d3f20ba6a656fe84ce54c6ce">value_cmp_si</a>(M-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][0], 2)) {
<a name="l00779"></a>00779             <a class="code" href="matrix__addon_8c.html#a79d19aa329285819b31bc7a602241842" title="use an eliminator row to eliminate a variable in a victim row (without changing the sign of the victi...">eliminate_var_with_constr</a>(EqsMTmp, i, M, j, k+nbVars);
<a name="l00780"></a>00780           }
<a name="l00781"></a>00781         }
<a name="l00782"></a>00782       }
<a name="l00783"></a>00783     }
<a name="l00784"></a>00784     <span class="comment">/* if (k==-1): count the tautologies in Eqs to remove them later */</span>
<a name="l00785"></a>00785     <span class="keywordflow">else</span> {
<a name="l00786"></a>00786       allZeros++;
<a name="l00787"></a>00787     }
<a name="l00788"></a>00788   }
<a name="l00789"></a>00789   
<a name="l00790"></a>00790   <span class="comment">/* elimParms may have been overallocated. Now we know how many parms have</span>
<a name="l00791"></a>00791 <span class="comment">     been eliminated so we can reallocate the right amount of memory. */</span>
<a name="l00792"></a>00792   <span class="keywordflow">if</span> (!realloc((*elimParms), ((*elimParms)[0]+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>))) {
<a name="l00793"></a>00793     fprintf(stderr, <span class="stringliteral">&quot;Constraints_Remove_parm_eqs &gt; cannot realloc()&quot;</span>);
<a name="l00794"></a>00794   }
<a name="l00795"></a>00795 
<a name="l00796"></a>00796   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(EqsMTmp);
<a name="l00797"></a>00797 
<a name="l00798"></a>00798   <span class="comment">/* 3- remove the &quot;bad&quot; equalities from the input matrices</span>
<a name="l00799"></a>00799 <span class="comment">     and copy the equalities involving only parameters */</span>
<a name="l00800"></a>00800   EqsMTmp = <a class="code" href="matrix_8c.html#ac0b29e1d99a2823ad00b5f2157879d80">Matrix_Alloc</a>(M-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>-nbEqsM-nbTautoM, M-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>);
<a name="l00801"></a>00801   k=0;
<a name="l00802"></a>00802   <span class="keywordflow">for</span> (i=0; i&lt; M-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>; i++) {
<a name="l00803"></a>00803     <span class="keywordflow">if</span> (<a class="code" href="arithmetique_8h.html#afee537d2d3f20ba6a656fe84ce54c6ce">value_cmp_si</a>(M-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][0], 2)) {
<a name="l00804"></a>00804       <a class="code" href="vector_8c.html#ab6eca9ad03a2f4a60dd79182289e0e0b">Vector_Copy</a>(M-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i], EqsMTmp-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[k], M-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>);
<a name="l00805"></a>00805       k++;
<a name="l00806"></a>00806     }
<a name="l00807"></a>00807   }
<a name="l00808"></a>00808   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(M);
<a name="l00809"></a>00809   (*M1) = EqsMTmp;
<a name="l00810"></a>00810   
<a name="l00811"></a>00811   EqsMTmp = <a class="code" href="matrix_8c.html#ac0b29e1d99a2823ad00b5f2157879d80">Matrix_Alloc</a>(Ctxt-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>-nbEqsCtxt-nbTautoCtxt, Ctxt-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>);
<a name="l00812"></a>00812   k=0;
<a name="l00813"></a>00813   <span class="keywordflow">for</span> (i=0; i&lt; Ctxt-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>; i++) {
<a name="l00814"></a>00814     <span class="keywordflow">if</span> (<a class="code" href="arithmetique_8h.html#a47d32925340d2dc99ef2d4215080a60d">value_notzero_p</a>(Ctxt-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][0])) {
<a name="l00815"></a>00815       <a class="code" href="vector_8c.html#ab6eca9ad03a2f4a60dd79182289e0e0b">Vector_Copy</a>(Ctxt-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i], EqsMTmp-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[k], Ctxt-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>);
<a name="l00816"></a>00816       k++;
<a name="l00817"></a>00817     }
<a name="l00818"></a>00818   }
<a name="l00819"></a>00819   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(Ctxt);
<a name="l00820"></a>00820   (*Ctxt1) = EqsMTmp;
<a name="l00821"></a>00821   
<a name="l00822"></a>00822   <span class="keywordflow">if</span> (renderSpace==0) {<span class="comment">/* renderSpace=0: equalities in the parameter space */</span>
<a name="l00823"></a>00823     EqsMTmp = <a class="code" href="matrix_8c.html#ac0b29e1d99a2823ad00b5f2157879d80">Matrix_Alloc</a>(Eqs-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>-allZeros, Eqs-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>);
<a name="l00824"></a>00824     k=0;
<a name="l00825"></a>00825     <span class="keywordflow">for</span> (i=0; i&lt;Eqs-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>; i++) {
<a name="l00826"></a>00826       <span class="keywordflow">if</span> (<a class="code" href="vector_8c.html#ab719ec10095622cd0ad8024da53cdd4c">First_Non_Zero</a>(Eqs-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i], Eqs-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>)!=-1) {
<a name="l00827"></a>00827         <a class="code" href="vector_8c.html#ab6eca9ad03a2f4a60dd79182289e0e0b">Vector_Copy</a>(Eqs-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i], EqsMTmp-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[k], Eqs-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>);
<a name="l00828"></a>00828         k++;
<a name="l00829"></a>00829       }
<a name="l00830"></a>00830     }
<a name="l00831"></a>00831   }
<a name="l00832"></a>00832   <span class="keywordflow">else</span> {<span class="comment">/* renderSpace=1: equalities rendered in the combined space */</span>
<a name="l00833"></a>00833     EqsMTmp = <a class="code" href="matrix_8c.html#ac0b29e1d99a2823ad00b5f2157879d80">Matrix_Alloc</a>(Eqs-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>-allZeros, (*M1)-&gt;NbColumns);
<a name="l00834"></a>00834     k=0;
<a name="l00835"></a>00835     <span class="keywordflow">for</span> (i=0; i&lt;Eqs-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>; i++) {
<a name="l00836"></a>00836       <span class="keywordflow">if</span> (<a class="code" href="vector_8c.html#ab719ec10095622cd0ad8024da53cdd4c">First_Non_Zero</a>(Eqs-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i], Eqs-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>)!=-1) {
<a name="l00837"></a>00837         <a class="code" href="vector_8c.html#ab6eca9ad03a2f4a60dd79182289e0e0b">Vector_Copy</a>(Eqs-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i], &amp;(EqsMTmp-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[k][nbVars]), Eqs-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>);
<a name="l00838"></a>00838         k++;
<a name="l00839"></a>00839       }
<a name="l00840"></a>00840     }
<a name="l00841"></a>00841   }
<a name="l00842"></a>00842   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(Eqs);
<a name="l00843"></a>00843   Eqs = EqsMTmp;
<a name="l00844"></a>00844 
<a name="l00845"></a>00845   <span class="keywordflow">return</span> Eqs;
<a name="l00846"></a>00846 } <span class="comment">/* Constraints_Remove_parm_eqs */</span>
<a name="l00847"></a>00847 
<a name="l00848"></a>00848 <span class="comment"></span>
<a name="l00849"></a>00849 <span class="comment">/** Removes equalities involving only parameters, but starting from a</span>
<a name="l00850"></a>00850 <span class="comment"> * Polyhedron and its context.</span>
<a name="l00851"></a>00851 <span class="comment"> * @param P the polyhedron</span>
<a name="l00852"></a>00852 <span class="comment"> * @param C P&#39;s context</span>
<a name="l00853"></a>00853 <span class="comment"> * @param renderSpace: 0 for the parameter space, =1 for the combined space.</span>
<a name="l00854"></a>00854 <span class="comment"> * @maxRays Polylib&#39;s usual &lt;i&gt;workspace&lt;/i&gt;.</span>
<a name="l00855"></a>00855 <span class="comment"> */</span>
<a name="l00856"></a><a class="code" href="compress__parms_8h.html#a86df15994f14c73d49980bbf61f6f7e5">00856</a> <a class="code" href="structpolyhedron.html">Polyhedron</a> * <a class="code" href="compress__parms_8c.html#a86df15994f14c73d49980bbf61f6f7e5" title="Removes equalities involving only parameters, but starting from a Polyhedron and its context...">Polyhedron_Remove_parm_eqs</a>(<a class="code" href="structpolyhedron.html">Polyhedron</a> ** P, <a class="code" href="structpolyhedron.html">Polyhedron</a> ** C, 
<a name="l00857"></a>00857                                         <span class="keywordtype">int</span> renderSpace, 
<a name="l00858"></a>00858                                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ** elimParms, 
<a name="l00859"></a>00859                                         <span class="keywordtype">int</span> <a class="code" href="testCompressParms_8c.html#a508eb31b6faa4939e1c32adaef41b8c8">maxRays</a>) {
<a name="l00860"></a>00860   <a class="code" href="structmatrix.html">Matrix</a> * Eqs;
<a name="l00861"></a>00861   <a class="code" href="structpolyhedron.html">Polyhedron</a> * Peqs;
<a name="l00862"></a>00862   <a class="code" href="structmatrix.html">Matrix</a> * M = <a class="code" href="polyhedron_8c.html#a69417a994cd682d0c391ecff6d223cd2">Polyhedron2Constraints</a>((*P));
<a name="l00863"></a>00863   <a class="code" href="structmatrix.html">Matrix</a> * Ct = <a class="code" href="polyhedron_8c.html#a69417a994cd682d0c391ecff6d223cd2">Polyhedron2Constraints</a>((*C));
<a name="l00864"></a>00864 
<a name="l00865"></a>00865   <span class="comment">/* if the Minkowski representation is not computed yet, do not compute it in</span>
<a name="l00866"></a>00866 <span class="comment">     Constraints2Polyhedron */</span>
<a name="l00867"></a>00867   <span class="keywordflow">if</span> (<a class="code" href="types_8h.html#a19f1ae711bb0e3063ba1962cb8a898a0">F_ISSET</a>((*P), <a class="code" href="types_8h.html#a2ac4c28a3acbe4578e03ad20db7939cc">POL_VALID</a> | <a class="code" href="types_8h.html#a1869e11b8e9a1e9e89e8145c242e0eea">POL_INEQUALITIES</a>) &amp;&amp; 
<a name="l00868"></a>00868       (<a class="code" href="types_8h.html#a19f1ae711bb0e3063ba1962cb8a898a0">F_ISSET</a>((*C), <a class="code" href="types_8h.html#a2ac4c28a3acbe4578e03ad20db7939cc">POL_VALID</a> | <a class="code" href="types_8h.html#a1869e11b8e9a1e9e89e8145c242e0eea">POL_INEQUALITIES</a>))) {
<a name="l00869"></a>00869     <a class="code" href="types_8h.html#acd3e6da08aea98ada4bad87b9a63a4e0">FL_INIT</a>(maxRays, <a class="code" href="types_8h.html#a754586a0aee88f21ad4c98b1cddee1be">POL_NO_DUAL</a>);
<a name="l00870"></a>00870   }
<a name="l00871"></a>00871     
<a name="l00872"></a>00872   Eqs = <a class="code" href="compress__parms_8c.html#aca0035f9313236fd8046ab042180f544" title="Removes the equalities that involve only parameters, by eliminating some parameters in the polyhedron...">Constraints_Remove_parm_eqs</a>(&amp;M, &amp;Ct, renderSpace, elimParms);
<a name="l00873"></a>00873   Peqs = <a class="code" href="polyhedron_8c.html#aefb77665a187d751bdd44f106b12465e" title="Given a matrix of constraints (&#39;Constraints&#39;), construct and return a polyhedron.">Constraints2Polyhedron</a>(Eqs, maxRays);
<a name="l00874"></a>00874   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(Eqs);
<a name="l00875"></a>00875 
<a name="l00876"></a>00876   <span class="comment">/* particular case: no equality involving only parms is found */</span>
<a name="l00877"></a>00877   <span class="keywordflow">if</span> (Eqs-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>==0) {
<a name="l00878"></a>00878     <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(M);
<a name="l00879"></a>00879     <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(Ct);
<a name="l00880"></a>00880     <span class="keywordflow">return</span> Peqs;
<a name="l00881"></a>00881   }
<a name="l00882"></a>00882   <a class="code" href="polyhedron_8c.html#a4ae97b9794e3a616f1d38c68e6515cc3">Polyhedron_Free</a>(*P);
<a name="l00883"></a>00883   <a class="code" href="polyhedron_8c.html#a4ae97b9794e3a616f1d38c68e6515cc3">Polyhedron_Free</a>(*C);
<a name="l00884"></a>00884   (*P) = <a class="code" href="polyhedron_8c.html#aefb77665a187d751bdd44f106b12465e" title="Given a matrix of constraints (&#39;Constraints&#39;), construct and return a polyhedron.">Constraints2Polyhedron</a>(M, maxRays);
<a name="l00885"></a>00885   (*C) = <a class="code" href="polyhedron_8c.html#aefb77665a187d751bdd44f106b12465e" title="Given a matrix of constraints (&#39;Constraints&#39;), construct and return a polyhedron.">Constraints2Polyhedron</a>(Ct, maxRays);
<a name="l00886"></a>00886   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(M);
<a name="l00887"></a>00887   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(Ct);
<a name="l00888"></a>00888   <span class="keywordflow">return</span> Peqs;
<a name="l00889"></a>00889 } <span class="comment">/* Polyhedron_Remove_parm_eqs */</span>
<a name="l00890"></a>00890 
<a name="l00891"></a>00891 <span class="comment"></span>
<a name="l00892"></a>00892 <span class="comment">/**</span>
<a name="l00893"></a>00893 <span class="comment"> * Given a matrix with m parameterized equations, compress the nb_parms</span>
<a name="l00894"></a>00894 <span class="comment"> * parameters and n-m variables so that m variables are integer, and transform</span>
<a name="l00895"></a>00895 <span class="comment"> * the variable space into a n-m space by eliminating the m variables (using</span>
<a name="l00896"></a>00896 <span class="comment"> * the equalities) the variables to be eliminated are chosen automatically by</span>
<a name="l00897"></a>00897 <span class="comment"> * the function.</span>
<a name="l00898"></a>00898 <span class="comment"> * &lt;b&gt;Deprecated.&lt;/b&gt; Try to use Constraints_fullDimensionize instead.</span>
<a name="l00899"></a>00899 <span class="comment"> * @param M the constraints </span>
<a name="l00900"></a>00900 <span class="comment"> * @param the number of parameters</span>
<a name="l00901"></a>00901 <span class="comment"> * @param validityLattice the the integer lattice underlying the integer</span>
<a name="l00902"></a>00902 <span class="comment"> * solutions.</span>
<a name="l00903"></a>00903 <span class="comment">*/</span>
<a name="l00904"></a><a class="code" href="compress__parms_8h.html#a16589dade8bf119ae773e7991adc83ae">00904</a> <a class="code" href="structmatrix.html">Matrix</a> * <a class="code" href="compress__parms_8c.html#ab67657b853a34d82fdc72a3f771bc72c" title="Given a matrix with m parameterized equations, compress the nb_parms parameters and n-m variables so ...">full_dimensionize</a>(<a class="code" href="structmatrix.html">Matrix</a> <span class="keyword">const</span> * M, <span class="keywordtype">int</span> nbParms, 
<a name="l00905"></a>00905                            <a class="code" href="structmatrix.html">Matrix</a> ** validityLattice) {
<a name="l00906"></a>00906   <a class="code" href="structmatrix.html">Matrix</a> * Eqs, * Ineqs;
<a name="l00907"></a>00907   <a class="code" href="structmatrix.html">Matrix</a> * permutedEqs, * permutedIneqs;
<a name="l00908"></a>00908   <a class="code" href="structmatrix.html">Matrix</a> * Full_Dim;
<a name="l00909"></a>00909   <a class="code" href="structmatrix.html">Matrix</a> * WVL; <span class="comment">/* The Whole Validity Lattice (vars+parms) */</span>
<a name="l00910"></a>00910   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i,j;
<a name="l00911"></a>00911   <span class="keywordtype">int</span> nbElimVars;
<a name="l00912"></a>00912   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> * permutation, * permutationInv;
<a name="l00913"></a>00913   <span class="comment">/* 0- Split the equalities and inequalities from each other */</span>
<a name="l00914"></a>00914   <a class="code" href="matrix__addon_8c.html#a288db1ffeb5425aada82cabf5c824bc4" title="splits a matrix of constraints M into a matrix of equalities Eqs and a matrix of inequalities Ineqs a...">split_constraints</a>(M, &amp;Eqs, &amp;Ineqs);
<a name="l00915"></a>00915 
<a name="l00916"></a>00916   <span class="comment">/* 1- if the polyhedron is already full-dimensional, return it */</span>
<a name="l00917"></a>00917   <span class="keywordflow">if</span> (Eqs-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>==0) {
<a name="l00918"></a>00918     <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(Eqs);
<a name="l00919"></a>00919     (*validityLattice) = <a class="code" href="matrix__addon_8c.html#a33f64eb039ac943c1bddbafc3be3ece6">Identity_Matrix</a>(nbParms+1);
<a name="l00920"></a>00920     <span class="keywordflow">return</span> Ineqs;
<a name="l00921"></a>00921   }
<a name="l00922"></a>00922   nbElimVars = Eqs-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>;
<a name="l00923"></a>00923 
<a name="l00924"></a>00924   <span class="comment">/* 2- put the vars to be eliminated at the first positions, </span>
<a name="l00925"></a>00925 <span class="comment">     and compress the other vars/parms</span>
<a name="l00926"></a>00926 <span class="comment">     -&gt; [ variables to eliminate / parameters / variables to keep ] */</span>
<a name="l00927"></a>00927   permutation = <a class="code" href="matrix__permutations_8c.html#af43c186b57b2df6caa02a812c175a4d1" title="finds a valid permutation : for a set of m equations, find m variables that will be put at the beginn...">find_a_permutation</a>(Eqs, nbParms);
<a name="l00928"></a>00928   <span class="keywordflow">if</span> (<a class="code" href="compress__parms_8c.html#a22fb119bf6f583cf5b74c2bddaa53e70" title="debug flags (2 levels)">dbgCompParm</a>) {
<a name="l00929"></a>00929     printf(<span class="stringliteral">&quot;Permuting the vars/parms this way: [ &quot;</span>);
<a name="l00930"></a>00930     <span class="keywordflow">for</span> (i=0; i&lt; Eqs-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>; i++) {
<a name="l00931"></a>00931       printf(<span class="stringliteral">&quot;%d &quot;</span>, permutation[i]);
<a name="l00932"></a>00932     }
<a name="l00933"></a>00933     printf(<span class="stringliteral">&quot;]\n&quot;</span>);
<a name="l00934"></a>00934   }
<a name="l00935"></a>00935   permutedEqs = <a class="code" href="matrix__permutations_8c.html#ae642907b1f7aac2f4ec8f174b27ab830" title="permutes the variables of the constraints of a polyhedron">mpolyhedron_permute</a>(Eqs, permutation);
<a name="l00936"></a>00936   WVL = <a class="code" href="compress__parms_8c.html#a4877b02bfffc51db4d9ac702475c3765" title="Given a parameterized constraints matrix with m equalities, computes the compression matrix G such th...">compress_parms</a>(permutedEqs, Eqs-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>-2-Eqs-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>);
<a name="l00937"></a>00937   <span class="keywordflow">if</span> (<a class="code" href="compress__parms_8c.html#a22fb119bf6f583cf5b74c2bddaa53e70" title="debug flags (2 levels)">dbgCompParm</a>) {
<a name="l00938"></a>00938     printf(<span class="stringliteral">&quot;Whole validity lattice: &quot;</span>);
<a name="l00939"></a>00939     <a class="code" href="matrix__addon_8h.html#a11468159c7fa7d75fadfa10e2e929fee" title="Polylib matrix addons Mainly, deals with polyhedra represented in implicit form (set of constraints)...">show_matrix</a>(WVL);
<a name="l00940"></a>00940   }
<a name="l00941"></a>00941   <a class="code" href="matrix__addon_8c.html#a44f487e1b38f0f47c115d2115087a017" title="compress the last vars/pars of the polyhedron M expressed as a polylib matrix">mpolyhedron_compress_last_vars</a>(permutedEqs, WVL);
<a name="l00942"></a>00942   permutedIneqs = <a class="code" href="matrix__permutations_8c.html#ae642907b1f7aac2f4ec8f174b27ab830" title="permutes the variables of the constraints of a polyhedron">mpolyhedron_permute</a>(Ineqs, permutation);
<a name="l00943"></a>00943   <span class="keywordflow">if</span> (<a class="code" href="compress__parms_8c.html#a22fb119bf6f583cf5b74c2bddaa53e70" title="debug flags (2 levels)">dbgCompParm</a>) {
<a name="l00944"></a>00944     <a class="code" href="matrix__addon_8h.html#a11468159c7fa7d75fadfa10e2e929fee" title="Polylib matrix addons Mainly, deals with polyhedra represented in implicit form (set of constraints)...">show_matrix</a>(permutedEqs);
<a name="l00945"></a>00945   }
<a name="l00946"></a>00946   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(Eqs);
<a name="l00947"></a>00947   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(Ineqs);
<a name="l00948"></a>00948   <a class="code" href="matrix__addon_8c.html#a44f487e1b38f0f47c115d2115087a017" title="compress the last vars/pars of the polyhedron M expressed as a polylib matrix">mpolyhedron_compress_last_vars</a>(permutedIneqs, WVL);
<a name="l00949"></a>00949   <span class="keywordflow">if</span> (<a class="code" href="compress__parms_8c.html#a22fb119bf6f583cf5b74c2bddaa53e70" title="debug flags (2 levels)">dbgCompParm</a>) {
<a name="l00950"></a>00950     printf(<span class="stringliteral">&quot;After compression: &quot;</span>);
<a name="l00951"></a>00951     <a class="code" href="matrix__addon_8h.html#a11468159c7fa7d75fadfa10e2e929fee" title="Polylib matrix addons Mainly, deals with polyhedra represented in implicit form (set of constraints)...">show_matrix</a>(permutedIneqs);
<a name="l00952"></a>00952   }
<a name="l00953"></a>00953   <span class="comment">/* 3- eliminate the first variables */</span>
<a name="l00954"></a>00954   <span class="keywordflow">if</span> (!<a class="code" href="matrix__addon_8c.html#a649c9050ca9d6229d5b48e966da1f35c" title="use a set of m equalities Eqs to eliminate m variables in the polyhedron Ineqs represented as a matri...">mpolyhedron_eliminate_first_variables</a>(permutedEqs, permutedIneqs)) {
<a name="l00955"></a>00955     fprintf(stderr,<span class="stringliteral">&quot;full-dimensionize &gt; variable elimination failed. \n&quot;</span>); 
<a name="l00956"></a>00956     <span class="keywordflow">return</span> NULL;
<a name="l00957"></a>00957   }
<a name="l00958"></a>00958   <span class="keywordflow">if</span> (<a class="code" href="compress__parms_8c.html#a22fb119bf6f583cf5b74c2bddaa53e70" title="debug flags (2 levels)">dbgCompParm</a>) {
<a name="l00959"></a>00959     printf(<span class="stringliteral">&quot;After elimination of the variables: &quot;</span>);
<a name="l00960"></a>00960     <a class="code" href="matrix__addon_8h.html#a11468159c7fa7d75fadfa10e2e929fee" title="Polylib matrix addons Mainly, deals with polyhedra represented in implicit form (set of constraints)...">show_matrix</a>(permutedIneqs);
<a name="l00961"></a>00961   }
<a name="l00962"></a>00962 
<a name="l00963"></a>00963   <span class="comment">/* 4- get rid of the first (zero) columns, </span>
<a name="l00964"></a>00964 <span class="comment">     which are now useless, and put the parameters back at the end */</span>
<a name="l00965"></a>00965   Full_Dim = <a class="code" href="matrix_8c.html#ac0b29e1d99a2823ad00b5f2157879d80">Matrix_Alloc</a>(permutedIneqs-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>,
<a name="l00966"></a>00966                           permutedIneqs-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>-nbElimVars);
<a name="l00967"></a>00967   <span class="keywordflow">for</span> (i=0; i&lt; permutedIneqs-&gt;<a class="code" href="structmatrix.html#a16ad614d15c6e81c0041e877b623c72d">NbRows</a>; i++) {
<a name="l00968"></a>00968     <a class="code" href="arithmetique_8h.html#a8cc56567a4a29271559ac0fd5f6c5bfa">value_set_si</a>(Full_Dim-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][0], 1);
<a name="l00969"></a>00969     <span class="keywordflow">for</span> (j=0; j&lt; nbParms; j++) 
<a name="l00970"></a>00970       <a class="code" href="arithmetique_8h.html#a864613888dc46f15679aa4f63e468f89">value_assign</a>(Full_Dim-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][j+Full_Dim-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>-nbParms-1], 
<a name="l00971"></a>00971                    permutedIneqs-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][j+nbElimVars+1]);
<a name="l00972"></a>00972     <span class="keywordflow">for</span> (j=0; j&lt; permutedIneqs-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>-nbParms-2-nbElimVars; j++) 
<a name="l00973"></a>00973       <a class="code" href="arithmetique_8h.html#a864613888dc46f15679aa4f63e468f89">value_assign</a>(Full_Dim-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][j+1], 
<a name="l00974"></a>00974                    permutedIneqs-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][nbElimVars+nbParms+j+1]);
<a name="l00975"></a>00975     <a class="code" href="arithmetique_8h.html#a864613888dc46f15679aa4f63e468f89">value_assign</a>(Full_Dim-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][Full_Dim-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>-1], 
<a name="l00976"></a>00976                  permutedIneqs-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][permutedIneqs-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>-1]);
<a name="l00977"></a>00977   }
<a name="l00978"></a>00978   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(permutedIneqs);
<a name="l00979"></a>00979   
<a name="l00980"></a>00980   <span class="comment">/* 5- Keep only the the validity lattice restricted to the parameters */</span>
<a name="l00981"></a>00981   *validityLattice = <a class="code" href="matrix_8c.html#ac0b29e1d99a2823ad00b5f2157879d80">Matrix_Alloc</a>(nbParms+1, nbParms+1);
<a name="l00982"></a>00982   <span class="keywordflow">for</span> (i=0; i&lt; nbParms; i++) {
<a name="l00983"></a>00983     <span class="keywordflow">for</span> (j=0; j&lt; nbParms; j++)
<a name="l00984"></a>00984       <a class="code" href="arithmetique_8h.html#a864613888dc46f15679aa4f63e468f89">value_assign</a>((*validityLattice)-&gt;p[i][j], 
<a name="l00985"></a>00985                    WVL-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][j]);
<a name="l00986"></a>00986     <a class="code" href="arithmetique_8h.html#a864613888dc46f15679aa4f63e468f89">value_assign</a>((*validityLattice)-&gt;p[i][nbParms], 
<a name="l00987"></a>00987                  WVL-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[i][WVL-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>-1]);
<a name="l00988"></a>00988   }
<a name="l00989"></a>00989   <span class="keywordflow">for</span> (j=0; j&lt; nbParms; j++) 
<a name="l00990"></a>00990     <a class="code" href="arithmetique_8h.html#a8cc56567a4a29271559ac0fd5f6c5bfa">value_set_si</a>((*validityLattice)-&gt;p[nbParms][j], 0);
<a name="l00991"></a>00991   <a class="code" href="arithmetique_8h.html#a864613888dc46f15679aa4f63e468f89">value_assign</a>((*validityLattice)-&gt;p[nbParms][nbParms], 
<a name="l00992"></a>00992                WVL-&gt;<a class="code" href="structmatrix.html#a2c6d840d8d911ae95c2ae4fc96f4b5ba">p</a>[WVL-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>-1][WVL-&gt;<a class="code" href="structmatrix.html#a68858fd3b57684ef38bdfce13c65d182">NbColumns</a>-1]);
<a name="l00993"></a>00993 
<a name="l00994"></a>00994   <span class="comment">/* 6- Clean up */</span>
<a name="l00995"></a>00995   <a class="code" href="matrix_8c.html#afcb312b7c12a6997cd66964ecc34e1a6">Matrix_Free</a>(WVL);
<a name="l00996"></a>00996   <span class="keywordflow">return</span> Full_Dim;
<a name="l00997"></a>00997 } <span class="comment">/* full_dimensionize */</span>
<a name="l00998"></a>00998 
<a name="l00999"></a>00999 <span class="preprocessor">#undef dbgCompParm</span>
<a name="l01000"></a>01000 <span class="preprocessor"></span><span class="preprocessor">#undef dbgCompParmMore</span>
</pre></div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="compress__parms_8c.html">compress_parms.c</a>      </li>
      <li class="footer">Generated on Sun Dec 18 2011 13:22:49 for polylib by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </li>
    </ul>
  </div>

</body>
</html>
